using Microsoft.Diagnostics.Tracing.EventPipe;
using Microsoft.Diagnostics.Tracing.Parsers;
using Microsoft.Diagnostics.Tracing.Parsers.Clr;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

namespace Microsoft.Diagnostics.Tracing
{
    /// <summary>
    /// EventPipeEventSource knows how to decode EventPipe (generated by the .NET core runtime).
    /// Please see <see href="https://github.com/Microsoft/perfview/blob/main/src/TraceEvent/EventPipe/EventPipeFormat.md" />for details on the file format.
    ///
    /// By conventions files of such a format are given the .netperf suffix and are logically
    /// very much like a ETL file in that they have a header that indicate things about
    /// the trace as a whole, and a list of events.    Like more modern ETL files the
    /// file as a whole is self-describing.    Some of the events are 'MetaData' events
    /// that indicate the provider name, event name, and payload field names and types.
    /// Ordinary events then point at these meta-data event so that logically all
    /// events have a name some basic information (process, thread, timestamp, activity
    /// ID) and user defined field names and values of various types.
    /// </summary>
    public unsafe class EventPipeEventSource : TraceEventDispatcher
    {
        public EventPipeEventSource(string fileName)
            : this(new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read | FileShare.Delete), false)
        {
        }

        public EventPipeEventSource(Stream stream)
            : this(stream, true)
        {
        }

        private EventPipeEventSource(Stream stream, bool isStreaming)
        {
            _stream = new RewindableStream(stream);
            _isStreaming = isStreaming;
            osVersion = new Version("0.0.0.0");
            cpuSpeedMHz = 10;

            // when streaming we defer parsing the headers until the call to Process()
            if (!isStreaming)
                ParseHeadersAndInitCaches();
        }

        internal const int MinSupportedMajorVersion = 3;
        internal const int MaxSupportedMajorVersion = 6;

        private void ParseHeadersAndInitCaches()
        {
            ParseHeaders();
            InitCaches();
        }

        // Parses the stream headers + TraceBlock and inits the right _parser implementation depending on file format version.
        private void ParseHeaders()
        {
            byte[] netTraceMagic = new byte[8];
            _stream.Read(netTraceMagic);
            byte[] expectedMagic = Encoding.UTF8.GetBytes("Nettrace");
            bool isNetTrace = true;
            bool isFastSerialization = true;
            if (!netTraceMagic.SequenceEqual(expectedMagic))
            {
                // The older netperf format didn't have this 'Nettrace' magic on it.
                _stream.CacheUnusedBytes(netTraceMagic);
                isNetTrace = false;
            }

            if (isNetTrace)
            {
                // After the NetTrace header is either a reserved 4 byte zero field: version >= 6
                // or the FastSerialization header: version <= 5
                Span<byte> reservedBytes = stackalloc byte[4];
                _stream.Read(reservedBytes);
                int reserved = MemoryMarshal.Read<int>(reservedBytes);
                if (reserved != 0)
                {
                    _stream.CacheUnusedBytes(reservedBytes);
                    // the FastSerializationObjectParser will set FileFormatVersionNumber when it parses the TraceBlock
                }
                else
                {
                    int major = _stream.Read<int>();
                    if (major < 6)
                    {
                        throw new FormatException($"Invalid NetTrace versioning header");
                    }
                    ThrowIfMajorVersionNotSupported(major);

                    // we don't use minor version for anything yet. Minor version bumps are for non-breaking changes so this reader
                    // should be compatible regardless of the minor version.
                    int minor = _stream.Read<int>();
                    FileFormatVersionNumber = major;
                    isFastSerialization = false;
                }
            }

            if (isFastSerialization)
            {
                _parser = new FastSerializationObjectParser(this, _stream, isNetTrace);
            }
            else
            {
                _parser = new V6BlockParser(this, _stream);
            }

            _parser.ParseTraceBlock();
        }

        internal void ThrowIfMajorVersionNotSupported(int majorVersion)
        {
            if (majorVersion < MinSupportedMajorVersion || majorVersion > MaxSupportedMajorVersion)
            {
                throw new UnsupportedFormatVersionException(majorVersion, MinSupportedMajorVersion, MaxSupportedMajorVersion);
            }
        }

        private void InitCaches()
        {
            _threadCache = new ThreadCache(FileFormatVersionNumber, _processId);
            EventCache = new EventCache(this, _threadCache);
            EventCache.OnEvent += EventCache_OnEvent;
            EventCache.OnEventsDropped += EventCache_OnEventsDropped;
            StackCache = new StackCache();
            LabelListCache = new LabelListCache();
        }

        public DateTime QPCTimeToTimeStamp(long QPCTime)
        {
            return base.QPCTimeToDateTimeUTC(QPCTime).ToLocalTime();
        }

        public Dictionary<string, string> HeaderKeyValuePairs { get; } = new Dictionary<string, string>();

        #region private
        // I put these in the private section because they are overrides, and thus don't ADD to the API.
        public override int EventsLost => _eventsLost;

        /// <summary>
        /// Called after headers are deserialized. This is especially useful in a streaming scenario
        /// because the headers are only read after Process() is called.
        /// </summary>
        internal Action HeadersDeserialized;

        protected override void Dispose(bool disposing)
        {
            if (_parser != null)
            {
                _parser.Dispose();
            }

            base.Dispose(disposing);
        }

        public override bool Process()
        {
            // If we are streaming we defer header parsing until now, otherwise we do it in the constructor
            if (_isStreaming)
            {
                ParseHeadersAndInitCaches();
            }

            HeadersDeserialized?.Invoke();
            _parser.ParseRemainder();
            return true;
        }

        internal int FileFormatVersionNumber { get; set; }
        internal EventCache EventCache { get; private set; }
        internal StackCache StackCache { get; private set; }
        internal LabelListCache LabelListCache { get; private set; }

        internal override string ProcessName(int processID, long timeQPC) => string.Format("Process({0})", processID);

        internal void ReadTraceObjectV3To5(Block block)
        {
            SpanReader reader = block.Reader;
            // The start time is stored as a SystemTime which is a bunch of shorts, convert to DateTime.
            short year = reader.ReadInt16();
            short month = reader.ReadInt16();
            short dayOfWeek = reader.ReadInt16();
            short day = reader.ReadInt16();
            short hour = reader.ReadInt16();
            short minute = reader.ReadInt16();
            short second = reader.ReadInt16();
            short milliseconds = reader.ReadInt16();
            _syncTimeUTC = new DateTime(year, month, day, hour, minute, second, milliseconds, DateTimeKind.Utc);
            _syncTimeQPC = reader.ReadInt64();
            _QPCFreq = reader.ReadInt64();

            sessionStartTimeQPC = _syncTimeQPC;
            pointerSize = reader.ReadInt32();
            _processId = reader.ReadInt32();
            numberOfProcessors = reader.ReadInt32();
            _expectedCPUSamplingRate = reader.ReadInt32();
        }

        internal void ReadTraceBlockV6OrGreater(Block block)
        {
            SpanReader reader = block.Reader;
            short year = reader.ReadInt16();
            short month = reader.ReadInt16();
            short dayOfWeek = reader.ReadInt16();
            short day = reader.ReadInt16();
            short hour = reader.ReadInt16();
            short minute = reader.ReadInt16();
            short second = reader.ReadInt16();
            short milliseconds = reader.ReadInt16();
            _syncTimeUTC = new DateTime(year, month, day, hour, minute, second, milliseconds, DateTimeKind.Utc);
            _syncTimeQPC = reader.ReadInt64();
            _QPCFreq = reader.ReadInt64();

            sessionStartTimeQPC = _syncTimeQPC;
            pointerSize = reader.ReadInt32();

            int keyValuePairs = reader.ReadInt32();
            for (int i = 0; i < keyValuePairs; i++)
            {
                string key = reader.ReadVarUIntUTF8String();
                string value = reader.ReadVarUIntUTF8String();
                HeaderKeyValuePairs[key] = value;

                // check for well-known key names
                if(key == "HardwareThreadCount" && int.TryParse(value, out int intVal))
                {
                    numberOfProcessors = intVal;
                }
                else if(key == "ProcessId" && int.TryParse(value, out int intVal2))
                {
                    _processId = intVal2;
                }
                else if (key == "ExpectedCPUSamplingRate" && int.TryParse(value, out int intVal3))
                {
                    _expectedCPUSamplingRate = intVal3;
                }
            }
        }

        internal void ReadEventBlockV3OrLess(Block block)
        {
            SpanReader eventBlockReader = block.Reader;
            while (eventBlockReader.RemainingBytes.Length > 0)
            {
                ReadAndProcessEvent(ref eventBlockReader);
            }
        }

        internal void ReadEventBlockV4OrGreater(Block block)
        {
            EventCache.ProcessEventBlock(block);
        }

        internal void ReadMetadataBlockV6OrGreater(Block block)
        {
            SpanReader reader = block.Reader;
            int headerSize = reader.ReadUInt16();
            reader.ReadBytes(headerSize);
            while(reader.RemainingBytes.Length > 0)
            {
                ReadAndCacheMetadataV6OrGreater(ref reader);
            }
        }

        internal void ReadMetadataBlockV5OrLess(Block block)
        {
            SpanReader metadataReader = block.Reader;

            short headerSize = metadataReader.ReadInt16();
            if(headerSize < 20)
            {
                throw new FormatException($"Invalid metadata header size {headerSize}");
            }
            SpanReader headerReader = metadataReader.CreateChildReader(headerSize - 2);
            short flags = headerReader.ReadInt16();

            EventPipeEventHeader eventHeader = new EventPipeEventHeader();
            while (metadataReader.RemainingBytes.Length > 0)
            {
                ReadEventHeader(ref metadataReader, (flags & (short)EventBlockFlags.HeaderCompression) != 0, ref eventHeader);
                long streamOffset = metadataReader.StreamOffset;
                SpanReader payloadReader = new SpanReader(metadataReader.ReadBytes(eventHeader.PayloadSize), streamOffset);
                ReadAndCacheMetadataV5OrLower(ref payloadReader);
            }
        }

        internal void ReadSequencePointBlockV5OrLess(Block block)
        {
            EventCache.ProcessSequencePointBlockV5OrLess(block);
            StackCache.Flush();
            LabelListCache.Flush();
        }

        internal void ReadSequencePointBlockV6OrGreater(Block block)
        {
            EventCache.ProcessSequencePointBlockV6OrGreater(block);
            StackCache.Flush();
            LabelListCache.Flush();
        }

        internal void ReadStackBlock(Block block)
        {
            StackCache.ProcessStackBlock(block);
        }

        internal void ReadLabelListBlock(Block block)
        {
            LabelListCache.ProcessLabelListBlock(block);
        }

        enum ThreadInfoKind
        {
            Name = 1,
            OSProcessId = 2,
            OSThreadId = 3,
            KeyValue = 4
        }

        internal void ReadThreadBlock(Block block)
        {
            Debug.Assert(FileFormatVersionNumber >= 6);

            SpanReader reader = block.Reader;
            while(reader.RemainingBytes.Length > 0)
            {
                ushort size = reader.ReadUInt16();
                long streamOffset = reader.StreamOffset;
                SpanReader threadReader = new SpanReader(reader.ReadBytes(size), streamOffset);
                long index = (long)threadReader.ReadVarUInt64();
                EventPipeThread thread = new EventPipeThread(-1, _processId);
                while (threadReader.RemainingBytes.Length > 0)
                {
                    ThreadInfoKind kind = (ThreadInfoKind)threadReader.ReadUInt8();
                    switch (kind)
                    {
                        case ThreadInfoKind.Name:
                            thread.Name = threadReader.ReadVarUIntUTF8String();
                            break;
                        case ThreadInfoKind.OSProcessId:
                            thread.ProcessId = (long)threadReader.ReadVarUInt64();
                            break;
                        case ThreadInfoKind.OSThreadId:
                            thread.ThreadId = (long)threadReader.ReadVarUInt64();
                            break;
                        case ThreadInfoKind.KeyValue:
                            string key = threadReader.ReadVarUIntUTF8String();
                            string value = threadReader.ReadVarUIntUTF8String();
                            thread.Attributes[key] = value;
                            break;
                        default:
                            throw new FormatException($"Unknown thread info kind {kind}");
                    }
                }
                if (_threadCache.ContainsKey(index))
                {
                    throw new FormatException($"Duplicate thread index {index} declared at stream offset 0x{streamOffset:x}");
                }
                _threadCache.AddThread(index, thread);
            }
        }

        internal void ReadRemoveThreadBlock(Block block)
        {
            Debug.Assert(FileFormatVersionNumber >= 6);

            SpanReader reader = block.Reader;
            while (reader.RemainingBytes.Length > 0)
            {
                long streamOffset = reader.StreamOffset;
                long index = (long)reader.ReadVarUInt64();
                int sequenceNumber = (int)reader.ReadVarUInt32();
                EventCache.CheckpointThreadAndPendRemoval(index, sequenceNumber);
            }
        }

        /// <summary>
        /// Parses one event from the stream. If it is a metadata event it is cached for later use.
        /// If it is a regular event it is dispatched to the registered event handlers.
        /// </summary>
        private void ReadAndProcessEvent(ref SpanReader reader)
        {
            Debug.Assert(FileFormatVersionNumber <= 3);
            EventPipeEventHeader header = new EventPipeEventHeader();
            ReadEventHeader(ref reader, false, ref header);
            ReadAndProcessEvent(ref reader, header);
        }

        /// <summary>
        /// Parses one event from the stream. If it is a metadata event it is cached for later use.
        /// If it is a regular event it is dispatched to the registered event handlers.
        /// The event header has already been parsed and the reader should be positioned at the start of the event payload.
        /// </summary>
        private void ReadAndProcessEvent(ref SpanReader reader, EventPipeEventHeader eventHeader)
        {
            Debug.Assert(FileFormatVersionNumber <= 3);
            long offset = reader.StreamOffset;
            SpanReader payloadReader = new SpanReader(reader.ReadBytes(eventHeader.PayloadSize), offset);
            if (eventHeader.IsMetadata())
            {
                ReadAndCacheMetadataV5OrLower(ref payloadReader);
            }
            else
            {
                DispatchEventRecord(ConvertEventHeaderToRecord(ref eventHeader));
            }
            if(eventHeader.PayloadSize < eventHeader.TotalNonHeaderSize)
            {
                // In V3 format and earlier there was a trailing stack trace after the event payload that we need to skip.
                reader.ReadBytes(eventHeader.TotalNonHeaderSize - eventHeader.PayloadSize);
            }
        }

        private void DispatchEventRecord(TraceEventNativeMethods.EVENT_RECORD* eventRecord)
        {
            if (eventRecord != null)
            {
                // in the code below we set sessionEndTimeQPC to be the timestamp of the last event.
                // Thus the new timestamp should be later, and not more than 1 day later.
                Debug.Assert(sessionEndTimeQPC <= eventRecord->EventHeader.TimeStamp);
                Debug.Assert(sessionEndTimeQPC == 0 || eventRecord->EventHeader.TimeStamp - sessionEndTimeQPC < _QPCFreq * 24 * 3600);

                var traceEvent = Lookup(eventRecord);
                if (traceEvent.NeedsFixup)
                {
                    traceEvent.FixupData();
                }
                Dispatch(traceEvent);
                sessionEndTimeQPC = eventRecord->EventHeader.TimeStamp;
            }
        }

        internal void ReadEventHeader(ref SpanReader reader, bool useHeaderCompression, ref EventPipeEventHeader eventData)
        {
            if (FileFormatVersionNumber <= 3)
            {
                EventPipeEventHeader.ReadFromFormatV3(ref reader, ref eventData);
                eventData.ProcessId = _processId;
            }
            else if (FileFormatVersionNumber <= 5)
            {
                EventPipeEventHeader.ReadFromFormatV4(ref reader, useHeaderCompression, ref eventData);
                eventData.ProcessId = _processId;
                if (eventData.MetaDataId != 0 && StackCache.TryGetStack(eventData.StackId, out int stackBytesSize, out IntPtr stackBytes))
                {
                    eventData.StackBytesSize = stackBytesSize;
                    eventData.StackBytes = stackBytes;
                }
            }
            else // if (FileFormatVersionNumber >= 6)
            {
                EventPipeEventHeader.ReadFromFormatV6(ref reader, useHeaderCompression, ref eventData);
                StackCache.TryGetStack(eventData.StackId, out int stackBytesSize, out IntPtr stackBytes);
                eventData.StackBytesSize = stackBytesSize;
                eventData.StackBytes = stackBytes;
                EventPipeThread thread = _threadCache.GetThread(eventData.ThreadIndexOrId);
                eventData.ProcessId = thread.ProcessId;
                eventData.ThreadId = thread.ThreadId;
                LabelList labelList = LabelListCache.GetLabelList(eventData.LabelListId);
                eventData.ActivityID = labelList.ActivityId.HasValue ? labelList.ActivityId.Value : Guid.Empty;
                eventData.RelatedActivityID = labelList.RelatedActivityId.HasValue ? labelList.RelatedActivityId.Value : Guid.Empty;
            }

            // Basic sanity checks.  Are the timestamps and sizes sane.
            Debug.Assert(sessionEndTimeQPC <= eventData.TimeStamp);
            Debug.Assert(sessionEndTimeQPC == 0 || eventData.TimeStamp - sessionEndTimeQPC < _QPCFreq * 24 * 3600);
            Debug.Assert(0 <= eventData.PayloadSize && eventData.PayloadSize <= eventData.TotalNonHeaderSize);
            Debug.Assert(0 <= eventData.TotalNonHeaderSize && eventData.TotalNonHeaderSize < 0x20000);  // TODO really should be 64K but BulkSurvivingObjectRanges needs fixing.
            Debug.Assert(FileFormatVersionNumber != 3 ||
                ((long)eventData.Payload % 4 == 0 && eventData.TotalNonHeaderSize % 4 == 0)); // ensure 4 byte alignment
        }

        /// <summary>
        /// Read the metadata payload and cache it for later use.
        /// </summary>
        /// <param name="reader">The reader should be exactly long enough for one metadata blob</param>
        private void ReadAndCacheMetadataV5OrLower(ref SpanReader reader)
        {
            EventPipeMetadata metadata = EventPipeMetadata.ReadV5OrLower(ref reader, PointerSize, _processId, FileFormatVersionNumber);
            Debug.Assert(reader.RemainingBytes.Length == 0);
            CacheMetadata(metadata);
        }

        /// <summary>
        /// Read the metadata payload and cache it for later use.
        /// </summary>
        private void ReadAndCacheMetadataV6OrGreater(ref SpanReader reader)
        {
            EventPipeMetadata metadata = EventPipeMetadata.ReadV6OrGreater(ref reader, PointerSize);
            CacheMetadata(metadata);
        }

        private void CacheMetadata(EventPipeMetadata metadata)
        {
            DynamicTraceEventData eventTemplate = CreateTemplate(metadata);
            _eventMetadataDictionary.Add(metadata.MetaDataId, metadata);
            _metadataTemplates[eventTemplate] = eventTemplate;
        }

        internal bool TryGetMetadata(int metadataId, out EventPipeMetadata metadata) =>  _eventMetadataDictionary.TryGetValue(metadataId, out metadata);
        internal bool TryGetThread(long threadIndex, out EventPipeThread thread) => _threadCache.TryGetValue(threadIndex, out thread);

        private TraceEventNativeMethods.EVENT_RECORD* ConvertEventHeaderToRecord(ref EventPipeEventHeader eventData)
        {
            if (_eventMetadataDictionary.TryGetValue(eventData.MetaDataId, out var metaData))
            {
                return metaData.GetEventRecordForEventData(eventData);
            }
            else
            {
                Debug.Assert(false, "Warning can't find metaData for ID " + eventData.MetaDataId);
                return null;
            }
        }

        internal override unsafe Guid GetRelatedActivityID(TraceEventNativeMethods.EVENT_RECORD* eventRecord)
        {
            if (FileFormatVersionNumber >= 4)
            {
                if (eventRecord->ExtendedDataCount != 0)
                {
                    var extendedData = eventRecord->ExtendedData;
                    for (int i = 0; i < eventRecord->ExtendedDataCount; i++)
                    {
                        if (extendedData[i].ExtType == TraceEventNativeMethods.EVENT_HEADER_EXT_TYPE_RELATED_ACTIVITYID)
                        {
                            return *((Guid*)extendedData[i].DataPtr);
                        }
                    }
                }

                return Guid.Empty;
            }
            else
            {
                // Recover the EventPipeEventHeader from the payload pointer and then fetch from the header.
                return EventPipeEventHeader.GetRelatedActivityID((byte*)eventRecord->UserData);
            }
        }

        // Expose data on the last parsed event label lists for testing purposes
        // If we want to get non-ActivityId info out through TraceEvent we'll need a proper API for this
        internal LabelList GetLastLabelList()
        {
            return LabelListCache.GetLabelList(_lastLabelListId);
        }

        private void EventCache_OnEvent(ref EventPipeEventHeader header)
        {
            _lastLabelListId = header.LabelListId;
            TraceEventNativeMethods.EVENT_RECORD* eventRecord = ConvertEventHeaderToRecord(ref header);
            ValidateStackFields(header, eventRecord);
            DispatchEventRecord(eventRecord);
        }

        private void EventCache_OnEventsDropped(int droppedEventCount)
        {
            long totalLostEvents = _eventsLost + droppedEventCount;
            _eventsLost = (int)Math.Min(totalLostEvents, int.MaxValue);
        }

        [Conditional("DEBUG")]
        private void ValidateStackFields(EventPipeEventHeader header, TraceEventNativeMethods.EVENT_RECORD* eventRecord)
        {
            bool hasStackExtendedData = false;
            for (int i = 0; i < eventRecord->ExtendedDataCount; i++)
            {
                if (eventRecord->ExtendedData[i].ExtType == TraceEventNativeMethods.EVENT_HEADER_EXT_TYPE_STACK_TRACE32 ||
                    eventRecord->ExtendedData[i].ExtType == TraceEventNativeMethods.EVENT_HEADER_EXT_TYPE_STACK_TRACE64)
                {
                    hasStackExtendedData = true;
                }
            }

            if (header.MetaDataId != 0 &&
                StackCache.TryGetStack(header.StackId, out int stackBytesSize, out IntPtr stackBytes) &&
                stackBytesSize != 0 && stackBytes != IntPtr.Zero) // Sometimes the values in the StackCache are zeros.
            {
                // .NET Core emits stacks for some events that we don't need and so they are excised out before we get here.
                if (_eventMetadataDictionary.TryGetValue(header.MetaDataId, out EventPipeMetadata metadataHeader) &&
                    (metadataHeader.ProviderId == ClrRundownTraceEventParser.ProviderGuid ||
                    (metadataHeader.ProviderId == ClrTraceEventParser.ProviderGuid && (140 <= metadataHeader.EventId && metadataHeader.EventId <= 144 || metadataHeader.EventId == 190))))
                {
                    Debug.Assert(!hasStackExtendedData);
                }
                else
                {
                    Debug.Assert(hasStackExtendedData);
                }
            }
            else
            {
                Debug.Assert(!hasStackExtendedData);
            }
        }
        internal bool TryGetTemplateFromMetadata(TraceEvent unhandledEvent, out DynamicTraceEventData template)
        {
            return _metadataTemplates.TryGetValue(unhandledEvent, out template);
        }

        private DynamicTraceEventData CreateTemplate(EventPipeMetadata metadata)
        {
            DynamicTraceEventData template = new DynamicTraceEventData(null, metadata.EventId, 0, metadata.EventName, Guid.Empty, metadata.Opcode, null, metadata.ProviderId, metadata.ProviderName);
            template.opcode = (TraceEventOpcode)metadata.Opcode;
            template.opcodeName = template.opcode.ToString();
            template.payloadNames = metadata.ParameterNames;
            template.payloadFetches = metadata.ParameterTypes;
            return template;
        }

        private Dictionary<int, EventPipeMetadata> _eventMetadataDictionary = new Dictionary<int, EventPipeMetadata>();
        private BlockParser _parser;
        private Dictionary<TraceEvent, DynamicTraceEventData> _metadataTemplates =
            new Dictionary<TraceEvent, DynamicTraceEventData>(new ExternalTraceEventParserState.TraceEventComparer());
        private int _eventsLost;
        private int _lastLabelListId;
        internal int _processId;
        internal int _expectedCPUSamplingRate;
        private RewindableStream _stream;
        private bool _isStreaming;
        private ThreadCache _threadCache;
        #endregion
    }


    public class UnsupportedFormatVersionException : FormatException
    {
        public UnsupportedFormatVersionException(int requestedVersion, int minSupportedVersion, int maxSupportedVersion) 
            : base($"NetTrace file format version {requestedVersion} is unsupported.")
        {
            RequestedVersion = requestedVersion;
            MinSupportedVersion = minSupportedVersion;
            MaxSupportedVersion = maxSupportedVersion;
        }

        public int RequestedVersion { get; }
        public int MinSupportedVersion { get; }
        public int MaxSupportedVersion { get; }
    }

#region private classes

    // This interfaces abstracts the logic that parses either the FastSerialization objects used up to version 5
    // or the simplified block format used in version 6 and later.
    internal interface IBlockParser : IDisposable
    {
        void ParseTraceBlock();
        void ParseRemainder();
    }

    internal abstract class BlockParser : IDisposable
    {
        protected EventPipeEventSource _source;
        protected RewindableStream _stream;
        private int _afterBlockCacheSize;
        protected BlockParser(EventPipeEventSource source, RewindableStream stream, int afterBlockCacheSize)
        {
            _source = source;
            _stream = stream;
            _afterBlockCacheSize = afterBlockCacheSize;
        }

        protected abstract void ParseBlock(Block block);
        protected abstract BlockHeader ReadBlockHeader();
        protected abstract void ReadBlockFooter();


        public void ParseTraceBlock()
        {
            using (Block block = ReadBlock())
            {
                if (block.Kind != BlockKind.Trace)
                {
                    throw new FormatException($"Expected Trace block, but got Kind={block.Kind} at stream offset 0x{block.StreamOffset:x}");
                }
                ParseBlock(block);
            }
            ReadBlockFooter();
        }

        public void ParseRemainder()
        {
            while (true)
            {
                using (Block block = ReadBlock())
                {
                    ParseBlock(block);
                    if (block.Kind == BlockKind.EndOfStream) break;
                    ReadBlockFooter();
                }
            }
        }

        public void Dispose()
        {
            _stream.Dispose();
        }

        private Block ReadBlock()
        {
            BlockHeader header = ReadBlockHeader();
            long blockStartOffset = _stream.Position;
            FixedBuffer buffer = new FixedBuffer(header.Length + _afterBlockCacheSize);
            bool success = false;
            long streamOffset = _stream.Position;
            try
            {
                int bytesRead = _stream.ReadAtLeast(buffer.Memory.Span, header.Length);
                if (bytesRead > header.Length)
                {
                    _stream.CacheUnusedBytes(buffer.Memory.Span.Slice(header.Length, bytesRead - header.Length));
                }
                success = true;
            }
            finally
            {
                if (!success)
                {
                    ((IDisposable)buffer).Dispose();
                }
            }
            return new Block(header.Kind, streamOffset, buffer.Memory.Slice(0, header.Length), buffer);
        }

        protected struct BlockHeader
        {
            public BlockHeader(BlockKind kind, int length)
            {
                Kind = kind;
                Length = length;
            }
            public BlockKind Kind;
            public int Length;
        }
    }

    internal class V6BlockParser : BlockParser
    {
        public V6BlockParser(EventPipeEventSource source, RewindableStream stream) : base(source, stream, 4) { }

        protected override BlockHeader ReadBlockHeader()
        {
            int headerInt = _stream.Read<int>();
            // See NetTraceFormat.md#Blocks for the description of the block header format.
            return new BlockHeader((BlockKind)(headerInt >> 24), headerInt & 0xFFFFFF);
        }

        protected override void ReadBlockFooter()
        {
            // do nothing, the V6 format doesn't have a footer
        }

        protected override void ParseBlock(Block block)
        {
            switch (block.Kind)
            {
                case BlockKind.Trace:
                    _source.ReadTraceBlockV6OrGreater(block);
                    break;
                case BlockKind.Event:
                    _source.ReadEventBlockV4OrGreater(block);
                    break;
                case BlockKind.Metadata:
                    _source.ReadMetadataBlockV6OrGreater(block);
                    break;
                case BlockKind.SequencePoint:
                    _source.ReadSequencePointBlockV6OrGreater(block);
                    break;
                case BlockKind.StackBlock:
                    _source.ReadStackBlock(block);
                    break;
                case BlockKind.Thread:
                    _source.ReadThreadBlock(block);
                    break;
                case BlockKind.RemoveThread:
                    _source.ReadRemoveThreadBlock(block);
                    break;
                case BlockKind.LabelList:
                    _source.ReadLabelListBlock(block);
                    break;
                case BlockKind.EndOfStream:
                    _source.EventCache.Flush();
                    return;
                default:
                    break; // ignore unknown block types so that the file format can be extended in the future
            }
        }
    }

    /// <summary>
    /// This parses older versions of the format which used the FastSerialization format. However this implementation
    /// doesn't use the FastSerialization library to implement it. This gives us more control over how the IO and memory
    /// management is done and keeps the code structurally more similar to how parsing is done V6.
    /// </summary>
    internal class FastSerializationObjectParser : BlockParser
    {
        bool _isNetTrace;
        public FastSerializationObjectParser(EventPipeEventSource source, RewindableStream stream, bool isNetTrace) : base(source, stream, 64)
        {
            _isNetTrace = isNetTrace;
            ValidateFastSerializationHeader();
        }

        private void ValidateFastSerializationHeader()
        {
            byte[] fastSerializationMagic = UTF8Encoding.UTF8.GetBytes("!FastSerialization.1");
            if (_stream.Read<int>() != fastSerializationMagic.Length)
            {
                throw new FormatException("Invalid FastSerialization header");
            }
            Span<byte> streamMagic = stackalloc byte[fastSerializationMagic.Length];
            _stream.Read(streamMagic);
            if (!streamMagic.SequenceEqual(fastSerializationMagic))
            {
                throw new FormatException("Invalid FastSerialization header");
            }
        }

        protected override BlockHeader ReadBlockHeader()
        {
            byte tag = _stream.Read<byte>();
            if (tag == (byte)FastSerializationTag.NullReference)
            {
                return new BlockHeader(BlockKind.EndOfStream, 0);
            }
            FastSerializationTag expectedBeginTag = _isNetTrace ? FastSerializationTag.BeginPrivateObject : FastSerializationTag.BeginObject;
            AssertTag(tag, expectedBeginTag);
            AssertTag(expectedBeginTag);
            AssertTag(FastSerializationTag.NullReference);
            int version = _stream.Read<int>();
            int minVersion = _stream.Read<int>();
            int typeLen = _stream.Read<int>();
            int maxLen = BlockName.EventPipeFile.Length;
            if (typeLen > maxLen)
            {
                throw new FormatException($"Invalid FastSerialization object type length {typeLen}");
            }
            Span<byte> typeName = stackalloc byte[typeLen];
            _stream.Read(typeName);
            AssertTag(FastSerializationTag.EndObject);

            int blockSize;
            BlockKind type;
            if (typeLen == BlockName.Trace.Length && typeName.SequenceEqual(BlockName.Trace))
            {
                type = BlockKind.Trace;
            }
            else if (typeLen == BlockName.EventPipeFile.Length && typeName.SequenceEqual(BlockName.EventPipeFile))
            {
                type = BlockKind.Trace;
            }
            else if (typeLen == BlockName.EventBlock.Length && typeName.SequenceEqual(BlockName.EventBlock))
            {
                type = BlockKind.Event;
            }
            else if (typeLen == BlockName.MetadataBlock.Length && typeName.SequenceEqual(BlockName.MetadataBlock))
            {
                type = BlockKind.Metadata;
            }
            else if (typeLen == BlockName.StackBlock.Length && typeName.SequenceEqual(BlockName.StackBlock))
            {
                type = BlockKind.StackBlock;
            }
            else if (typeLen == BlockName.SPBlock.Length && typeName.SequenceEqual(BlockName.SPBlock))
            {
                type = BlockKind.SequencePoint;
            }
            else
            {
                throw new FormatException("Unrecognized FastSerialization object type");
            }

            if (type == BlockKind.Trace)
            {
                if (version > 4)
                {
                    throw new FormatException("Unrecognized TraceBlock format version: " + version);
                }
                if((version == 4) != _isNetTrace)
                {
                    throw new FormatException("Unexpected TraceBlock format version: " + version);
                }
                _source.ThrowIfMajorVersionNotSupported(version);
                _source.FileFormatVersionNumber = version;

                blockSize = (version >= 3) ? 48 : 32;
                return new BlockHeader(BlockKind.Trace, blockSize);
            }

            if (version > 2)
            {
                throw new FormatException("Unrecognized block version: " + version);
            }

            blockSize = _stream.Read<int>();
            int curAlign = (int)(_stream.Position & 0x3);
            int alignPad = (4 - curAlign) & 0x3;
            Span<byte> alignPadBytes = stackalloc byte[alignPad];
            _stream.Read(alignPadBytes);
            return new BlockHeader(type, blockSize);
        }

        protected override void ReadBlockFooter()
        {
            AssertTag(FastSerializationTag.EndObject);
        }

        protected override void ParseBlock(Block block)
        {
            switch (block.Kind)
            {
                case BlockKind.Trace:
                    _source.ReadTraceObjectV3To5(block);
                    break;

                case BlockKind.Event:
                    if (_source.FileFormatVersionNumber >= 4)
                    {
                        _source.ReadEventBlockV4OrGreater(block);
                    }
                    else
                    {
                        _source.ReadEventBlockV3OrLess(block);
                    }
                    break;

                case BlockKind.Metadata:
                    _source.ReadMetadataBlockV5OrLess(block);
                    break;
                case BlockKind.SequencePoint:
                    _source.ReadSequencePointBlockV5OrLess(block);
                    break;
                case BlockKind.StackBlock:
                    _source.ReadStackBlock(block);
                    break;
                case BlockKind.EndOfStream:
                    _source.EventCache.Flush();
                    return;
                default:
                    throw new FormatException($"Unrecognized block type {block.Kind} at stream offset 0x{block.StreamOffset:x}");
            }
        }

        private void AssertTag(FastSerializationTag expected) => AssertTag(_stream.Read<byte>(), expected);

        private void AssertTag(byte tag, FastSerializationTag expected)
        {
            if (tag != (byte)expected)
            {
                throw new FormatException($"Expected tag {expected}, but got {tag}");
            }
        }

        // This is a subset of the tags used by the FastSerialization library. Because we no longer take a dependency
        // on the FastSerialization library I've got this duplicate definition for the specific tags that we use.
        enum FastSerializationTag : byte
        {
            NullReference = 1,
            BeginObject = 4,
            BeginPrivateObject = 5,
            EndObject = 6
        }

        static class BlockName
        {
            public static byte[] EventPipeFile = Encoding.UTF8.GetBytes("Microsoft.DotNet.Runtime.EventPipeFile");
            public static byte[] Trace = Encoding.UTF8.GetBytes("Trace");
            public static byte[] MetadataBlock = Encoding.UTF8.GetBytes("MetadataBlock");
            public static byte[] StackBlock = Encoding.UTF8.GetBytes("StackBlock");
            public static byte[] EventBlock = Encoding.UTF8.GetBytes("EventBlock");
            public static byte[] SPBlock = Encoding.UTF8.GetBytes("SPBlock");
        }

    }

    class Block : IDisposable
    {
        public Block(BlockKind kind, long streamOffset, Memory<byte> contents, FixedBuffer owner)
        {
            Kind = kind;
            StreamOffset = streamOffset;
            Contents = contents;
            _owner = owner;
        }

        private FixedBuffer _owner;
        public BlockKind Kind { get; }
        public Memory<byte> Contents { get; }
        public SpanReader Reader => new SpanReader(Contents.Span, StreamOffset);
        public long StreamOffset { get; }
        public FixedBuffer TakeOwnership()
        {
            FixedBuffer result = _owner;
            _owner = null;
            return result;
        }
        public void Dispose()
        {
            (_owner as IDisposable)?.Dispose();
        }
    }

    enum BlockKind
    {
        EndOfStream = 0,
        Trace = 1,
        Event = 2,
        Metadata = 3,
        SequencePoint = 4,
        StackBlock = 5,
        Thread = 6,
        RemoveThread = 7,
        LabelList = 8
    }

    internal enum EventBlockFlags : short
    {
        Uncompressed = 0,
        HeaderCompression = 1
    }

    /// <summary>
    /// Private utility class.
    ///
    /// At the start of every event from an EventPipe is a header that contains
    /// common fields like its size, threadID timestamp etc.  EventPipeEventHeader
    /// is the layout of this.  Events have two variable sized parts: the user
    /// defined fields, and the stack.   EventPipEventHeader knows how to
    /// decode these pieces (but provides no semantics for it.
    ///
    /// It is not a public type, but used in low level parsing of EventPipeEventSource.
    /// </summary>

    internal unsafe struct EventPipeEventHeader
    {
        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct LayoutV3
        {
            public int EventSize;          // Size bytes of this header and the payload and stacks if any.  does NOT encode the size of the EventSize field itself.
            public int MetaDataId;          // a number identifying the description of this event.
            public int ThreadId;
            public long TimeStamp;
            public Guid ActivityID;
            public Guid RelatedActivityID;
            public int PayloadSize;         // size in bytes of the user defined payload data.
        }

        public static void ReadFromFormatV3(ref SpanReader reader, ref EventPipeEventHeader header)
        {
            ref readonly LayoutV3 layout = ref reader.ReadRef<LayoutV3>();
            header.EventSize = layout.EventSize;
            header.MetaDataId = layout.MetaDataId;
            header.ThreadIndexOrId = header.ThreadId = layout.ThreadId;
            header.CaptureThreadIndexOrId = -1;
            header.CaptureProcNumber = -1;
            header.TimeStamp = layout.TimeStamp;
            header.ActivityID = layout.ActivityID;
            header.RelatedActivityID = layout.RelatedActivityID;
            header.PayloadSize = layout.PayloadSize;

            // these pointer conversions only work because the reader is backed by pinned memory
            header.Payload = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(reader.RemainingBytes));

            // we want to peak ahead and read some data in the stack part of the event without advancing the reader's cursor
            SpanReader eventReader = reader;
            eventReader.ReadBytes(layout.PayloadSize);
            header.StackBytesSize = eventReader.ReadInt32();
            header.StackBytes = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(eventReader.RemainingBytes));
            header.HeaderSize = sizeof(LayoutV3);
            int totalSize = header.EventSize + 4;
            header.TotalNonHeaderSize = totalSize - header.HeaderSize;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct LayoutV4
        {
            public int EventSize;           // Size bytes of this header and the payload. Does NOT encode the size of the EventSize field itself.
            public int MetaDataId;          // a number identifying the description of this event.
            public int SequenceNumber;
            public long ThreadId;
            public long CaptureThreadId;
            public int CaptureProcNumber;
            public int StackId;
            public long TimeStamp;
            public Guid ActivityID;
            public Guid RelatedActivityID;
            public int PayloadSize;         // size in bytes of the user defined payload data.
        }

        enum CompressedHeaderFlags
        {
            MetadataId = 1 << 0,
            CaptureThreadAndSequence = 1 << 1,
            ThreadId = 1 << 2,
            StackId = 1 << 3,
            LabelListId = 1 << 4,
            ActivityId = 1 << 4,
            RelatedActivityId = 1 << 5,
            Sorted = 1 << 6,
            DataLength = 1 << 7
        }

        public static void ReadFromFormatV4(ref SpanReader reader, bool useHeaderCompresion, ref EventPipeEventHeader header)
        {
            if (!useHeaderCompresion)
            {
                ref readonly LayoutV4 layout = ref reader.ReadRef<LayoutV4>();
                header.EventSize = layout.EventSize;
                header.MetaDataId = layout.MetaDataId & 0x7FFF_FFFF;
                header.IsSorted = ((uint)layout.MetaDataId & 0x8000_0000) == 0;
                header.SequenceNumber = layout.SequenceNumber;
                header.ThreadIndexOrId = header.ThreadId = layout.ThreadId;
                header.CaptureThreadIndexOrId = layout.CaptureThreadId;
                header.CaptureProcNumber = layout.CaptureProcNumber;
                header.StackId = layout.StackId;
                header.TimeStamp = layout.TimeStamp;
                header.ActivityID = layout.ActivityID;
                header.RelatedActivityID = layout.RelatedActivityID;
                header.PayloadSize = layout.PayloadSize;
                // these pointer conversions only work because the reader is backed by pinned memory
                header.Payload = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(reader.RemainingBytes));
                header.HeaderSize = sizeof(LayoutV4);
                header.TotalNonHeaderSize = header.PayloadSize;
            }
            else
            {
                long startOffset = reader.StreamOffset;
                byte flags = reader.ReadUInt8();
                if((flags & (byte)CompressedHeaderFlags.MetadataId) != 0)
                {
                    header.MetaDataId = (int)reader.ReadVarUInt32();
                }
                if ((flags & (byte)CompressedHeaderFlags.CaptureThreadAndSequence) != 0)
                {
                    header.SequenceNumber += (int)reader.ReadVarUInt32() + 1;
                    header.CaptureThreadIndexOrId = (long)reader.ReadVarUInt64();
                    header.CaptureProcNumber = (int)reader.ReadVarUInt32();
                }
                else
                {
                    if(header.MetaDataId != 0)
                    {
                        header.SequenceNumber++;
                    }
                }
                if ((flags & (byte)CompressedHeaderFlags.ThreadId) != 0)
                {
                    header.ThreadIndexOrId = header.ThreadId = (long)reader.ReadVarUInt64(); ;
                }
                if ((flags & (byte)CompressedHeaderFlags.StackId) != 0)
                {
                    header.StackId = (int)reader.ReadVarUInt32();
                }
                ulong timestampDelta = reader.ReadVarUInt64(); ;
                header.TimeStamp += (long)timestampDelta;
                if ((flags & (byte)CompressedHeaderFlags.ActivityId) != 0)
                {
                    header.ActivityID = reader.Read<Guid>();
                }
                if ((flags & (byte)CompressedHeaderFlags.RelatedActivityId) != 0)
                {
                    header.RelatedActivityID = reader.Read<Guid>();
                }
                header.IsSorted = (flags & (byte)CompressedHeaderFlags.Sorted) != 0;
                if ((flags & (byte)CompressedHeaderFlags.DataLength) != 0)
                {
                    header.PayloadSize = (int)reader.ReadVarUInt32();
                }
                header.HeaderSize = (int)(reader.StreamOffset - startOffset);

                // this only works because the span is backed by pinned memory
                header.Payload = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(reader.RemainingBytes));
                header.TotalNonHeaderSize = header.PayloadSize;
            }

            // These fields aren't read from the file itself, but must be reset on each read
            // to ensure that events that don't have a stack are handled properly.
            header.StackBytesSize = 0;
            header.StackBytes = IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        struct LayoutV6
        {
            public int EventSize;           // Size bytes of this header and the payload. Does NOT encode the size of the EventSize field itself.
            public int MetaDataId;          // a number identifying the description of this event.
            public int SequenceNumber;
            public long ThreadIndex;
            public long CaptureThreadIndex;
            public int CaptureProcNumber;
            public int StackId;
            public long TimeStamp;
            public int LabelListId;
            public int PayloadSize;         // size in bytes of the user defined payload data.
        }

        public static void ReadFromFormatV6(ref SpanReader reader, bool useHeaderCompresion, ref EventPipeEventHeader header)
        {
            if (!useHeaderCompresion)
            {
                ref readonly LayoutV6 layout = ref reader.ReadRef<LayoutV6>();
                header.EventSize = layout.EventSize;
                header.MetaDataId = layout.MetaDataId & 0x7FFF_FFFF;
                header.IsSorted = ((uint)layout.MetaDataId & 0x8000_0000) == 0;
                header.SequenceNumber = layout.SequenceNumber;
                header.ThreadIndexOrId = layout.ThreadIndex;
                header.CaptureThreadIndexOrId = layout.CaptureThreadIndex;
                header.CaptureProcNumber = layout.CaptureProcNumber;
                header.StackId = layout.StackId;
                header.TimeStamp = layout.TimeStamp;
                header.LabelListId = layout.LabelListId;
                header.PayloadSize = layout.PayloadSize;
                // these pointer conversions only work because the reader is backed by pinned memory
                header.Payload = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(reader.RemainingBytes));
                header.HeaderSize = sizeof(LayoutV4);
                header.TotalNonHeaderSize = header.PayloadSize;
            }
            else
            {
                long startOffset = reader.StreamOffset;
                byte flags = reader.ReadUInt8();
                if ((flags & (byte)CompressedHeaderFlags.MetadataId) != 0)
                {
                    header.MetaDataId = (int)reader.ReadVarUInt32();
                }
                if ((flags & (byte)CompressedHeaderFlags.CaptureThreadAndSequence) != 0)
                {
                    header.SequenceNumber += (int)reader.ReadVarUInt32() + 1;
                    header.CaptureThreadIndexOrId = (long)reader.ReadVarUInt64();
                    header.CaptureProcNumber = (int)reader.ReadVarUInt32();
                }
                else
                {
                    if (header.MetaDataId != 0)
                    {
                        header.SequenceNumber++;
                    }
                }
                if ((flags & (byte)CompressedHeaderFlags.ThreadId) != 0)
                {
                    header.ThreadIndexOrId = (long)reader.ReadVarUInt64(); ;
                }
                if ((flags & (byte)CompressedHeaderFlags.StackId) != 0)
                {
                    header.StackId = (int)reader.ReadVarUInt32();
                }
                ulong timestampDelta = reader.ReadVarUInt64(); ;
                header.TimeStamp += (long)timestampDelta;
                if ((flags & (byte)CompressedHeaderFlags.LabelListId) != 0)
                {
                    header.LabelListId = (int)reader.ReadVarUInt32();
                }
                header.IsSorted = (flags & (byte)CompressedHeaderFlags.Sorted) != 0;
                if ((flags & (byte)CompressedHeaderFlags.DataLength) != 0)
                {
                    header.PayloadSize = (int)reader.ReadVarUInt32();
                }
                header.HeaderSize = (int)(reader.StreamOffset - startOffset);

                // this only works because the span is backed by pinned memory
                header.Payload = (IntPtr)Unsafe.AsPointer<byte>(ref MemoryMarshal.GetReference(reader.RemainingBytes));
                header.TotalNonHeaderSize = header.PayloadSize;
            }
        }

        private int EventSize;          // Size bytes of this header and the payload and stacks if any. Does NOT encode the size of the EventSize field itself.
        public int MetaDataId;          // a number identifying the description of this event.
        public int SequenceNumber;
        public long CaptureThreadIndexOrId; // On format V6+ this is a thread index, otherwise it is an OS ID
        public int CaptureProcNumber;
        public long ThreadIndexOrId;    // On format V6+ this is a thread index, otherwise it is an OS ID
        public long ThreadId;
        public long ProcessId;
        public long TimeStamp;
        public int LabelListId;
        public Guid ActivityID;
        public Guid RelatedActivityID;
        public bool IsSorted;
        public int PayloadSize;         // size in bytes of the user defined payload data.
        public IntPtr Payload;
        public int StackId;
        public int StackBytesSize;
        public IntPtr StackBytes;
        public int HeaderSize;         // The size of the event up to the payload
        public int TotalNonHeaderSize; // The size of the payload, stack, and alignment padding


        public bool IsMetadata() => MetaDataId == 0; // 0 means that it's a metadata Id


#if SUPPORT_V1_V2
        /// <summary>
        /// Size of the event header + stack + payload (includes EventSize field itself)
        /// </summary>
        public static int GetTotalEventSize(byte* headerPtr, int formatVersion)
        {
            Debug.Assert(formatVersion <= 2);
            LayoutV3* header = (LayoutV3*)headerPtr;
            return header->EventSize + sizeof(int);
        }

        /// <summary>
        /// Header Size is defined to be the number of bytes before the Payload bytes.
        /// </summary>
        public static int GetHeaderSize(int formatVersion)
        {
            Debug.Assert(formatVersion <= 2);
            return sizeof(LayoutV3);
        }
#endif

        public static Guid GetRelatedActivityID(byte* headerPtr)
        {
            LayoutV3* header = (LayoutV3*)headerPtr;
            return header->RelatedActivityID;
        }
    }
#endregion
}
