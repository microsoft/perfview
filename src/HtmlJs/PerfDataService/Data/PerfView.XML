<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PerfView</name>
    </assembly>
    <members>
        <member name="M:Stats.ClrStats.Shorten(System.String)">
            <summary>
            Returns a shortened command line
            </summary>
            <param name="commandLine"></param>
            <returns></returns>
        </member>
        <member name="M:Stats.JitStats.BackgroundDiagCsv(System.String,Microsoft.Diagnostics.Tracing.Analysis.TraceLoadedDotNetRuntime,System.Collections.Generic.List{System.Object})">
            <summary>
            Write data about background JIT activities to 'outputCsvFilePath'
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.EventCount">
            <summary>
            Gets an estimated total number of samples created - not thread safe.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SkipPreamble(PerfView.Utilities.FastStream)">
            <summary>
            Tries to skip the byte order marks at the beginning of the given fast stream.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParseSkippingPreamble(System.String)">
            <summary>
            Parses the given Linux sample data, returning one sample at a time, and
            automatically skips the BOM at the beginning of files.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.Parse(PerfView.Utilities.FastStream)">
            <summary>
            Parse the given Linux sample data, returning one sample at a time, does not try to
            skip through the BOM.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.Pattern">
            <summary>
            Regex string pattern for filtering events.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.MaxSamples">
            <summary>
            The amount of samples the parser takes.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SetSymbolFile(System.IO.Compression.ZipArchive)">
            <summary>
            Uses the archive as a resource for symbol resolution when parsing Linux samples.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.SetSymbolFile(System.String)">
            <summary>
            Uses the path to open an archive with symbol files that are then used for symbol resolution when
            parsing Linux samples.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.GetSymbolFromMicrosoftMap(System.String,System.String)">
            <summary>
            Parses a Microsoft symbol as shown on the Linux sample. "entireSymbol" represents the module contract between
            the memory address and the dll path on the Linux sample.
            "mapFileLocation" is the path to the dll given by the Linux sample.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParseSymbolFile(System.IO.Stream,Diagnostics.Tracing.StackSources.Mapper)">
            <summary>
            Given a stream with the symbols, this function parses the stream and stores the contents in the given mapper
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.ParsePerfInfoFile(System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Given a stream that contains PerfInfo commands, parses the stream and stores data in the given dictionary.
            Key: somedll.ni.dll		Value: {some guid}
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptEventParser.GetFileName(System.String)">
            <summary>
            Can't use Path.GetFileName because it fails on illegal Linux file characters.  
            Can remove when this changes. 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.EventKind">
            <summary>
            Defines the kind of an event for easy casting.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.EventKind.Cpu">
            <summary>
            Represents an event that uses the cpu, and does not do anything special
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.EventKind.Scheduler">
            <summary>
            Represents an event that may context switch
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.SchedulerEvent">
            <summary>
            A sample that has extra properties to hold scheduled events.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.SchedulerEvent.Switch">
            <summary>
            The details of the context switch.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.ScheduleSwitch">
            <summary>
            Stores all relevant information retrieved by a context switch stack frame
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.LinuxEvent">
            <summary>
            A generic Linux event, all Linux events contain these properties.
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FrameKind.StackFrame">
            <summary>
            An actual stack frame from the simpling data
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FrameKind.ProcessFrame">
            <summary>
            A stack frame that represents the process of the sample
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FrameKind.ThreadFrame">
            <summary>
            A stack frame that represents the thread of the sample
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.FrameKind.BlockedCPUFrame">
            <summary>
            A stack frame that represents either blocked time or cpu time
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.Frame">
            <summary>
            A way to define different types of frames with different names on PerfView.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.StackFrame">
            <summary>
            Defines a single stack frame on a linux sample.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.ProcessFrame">
            <summary>
            Represents the name of the process.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.ThreadFrame">
            <summary>
            Represents the name of the thread and its ID.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.BlockedCPUFrame">
            <summary>
            A visual frame that represents whether or not a call stack was blocked or not.
            </summary>
        </member>
        <member name="P:Diagnostics.Tracing.StackSources.BlockedCPUFrame.SubKind">
            <summary>
            Represents whether the stack frame is BLOCKED_TIME or CPU_TIME
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptStackSource.CreateSampleFor(Diagnostics.Tracing.StackSources.LinuxEvent,Diagnostics.Tracing.StackSources.BlockedTimeAnalyzer)">
            <summary>
            Given a Linux event gotten from the trace, make its corresponding sample for the stack source.
            </summary>
        </member>
        <member name="M:Diagnostics.Tracing.StackSources.LinuxPerfScriptStackSource.AddSamples(System.Collections.Generic.IEnumerable{Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample})">
            <summary>
            Takes collection of samples, sorts them by time and then stores them.
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.BlockedTimeAnalyzer">
            <summary>
            Analyzes blocked time 
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.DebuggerStackSource">
            <summary>
            A DebuggerStackSource knows how to read a text file from the cdb (windbg) kc command output (clean stacks)
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FileSizeStackSource">
            <summary>
            A stack source that displays file size by path.     
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.FastDirectory">
             <summary>
             Turns out that Directory.GetFiles is not very efficient.  This is an alternative.    
            
             </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.OffProfStackSource">
            <summary>
            A WTReader knows how to read a text file from the cdb (windbg) WT command output
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.WTStackSource">
            <summary>
            A WTReader knows how to read a text file from the cdb (windbg) WT command output
            </summary>
        </member>
        <member name="F:Diagnostics.Tracing.StackSources.WTStackSource.WTStackElem.FirstCallStackIndex">
            <summary>
            When WT encounters tail call stubs it keeps the depth the same but changes the name.   
            we need the original call stack for to keep track of 'ExclInstrSoFar' but from a 
            users's perspective we clump the instructions into the original routine (before the tail call).
            FirstCallStackIndex is this 'original routine'.   TODO: Not clear this is the right answer....
            </summary>
        </member>
        <member name="T:Diagnostics.Tracing.StackSources.XmlStackSource">
            <summary>
            Reads a very reasonable XML encoding of a stack source. 
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Diagnostics.Tracing.StackSources.XmlStackSource.#ctor(System.String,System.Action{System.Xml.XmlReader})" -->
        <member name="T:PerfView.CommandLineArgs">
            <summary>
            The code:PerfViewCommandLine class holds the parsed form of all the commandLine line arguments.  It is
            initialized by handing it the 'args' array for main, and it has a public field for each named argument
            (eg -debug). See code:#CommandLineDefinitions for the code that defines the arguments (and the help
            strings associated with them). 
            
            See code:CommandLineParser for more on parser itself.   
            </summary>
        </member>
        <member name="M:PerfView.CommandLineArgs.ParseArgs(System.String[])">
            <summary>
            Sets CommandLineFailure field if there is a parse failure 
            </summary>
        </member>
        <member name="T:PerfView.CommandProcessor">
            <summary>
            CommandProcessor knows how to take a CommandLineArgs and do basic operations 
            that are NOT gui dependent.  
            </summary>
        </member>
        <member name="F:PerfView.CommandProcessor.ShowLog">
            <summary>
            Set to true if the command would like the Log viewed if possible
            </summary>
        </member>
        <member name="F:PerfView.CommandProcessor.NoExitOnElevate">
            <summary>
            If this is set, we don't exit the current process when we elevate
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.WaitForStart(PerfView.CommandLineArgs,System.Threading.ManualResetEvent)">
            <summary>
            If there are any command line arguments in 'parsedArgs' that indicate that we should wait until starting do so.
            'collectionCompleted' is an event that is fired when among other things the user manually dismisses the collection
            (so you should stop).  
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.SetWPRProviders(Microsoft.Diagnostics.Tracing.Session.TraceEventSession)">
            <summary>
            Mimics the WPR user mode providers 
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.SetCpuCounters(System.String[])">
            <summary>
            Parses cpuCounterSpecs and calls TraceEventSession.SetProfileSources 
            Each cpuCounterSpec is NAME:NUM tuple (e.g), for the allowable NAME use 
            the ListCpuCounters command.  
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.GetStatusLine(PerfView.CommandLineArgs,System.DateTime,System.String@)">
            <summary>
            Returns a status line for the collection that indicates how much data we have collected.  
            TODO review, I don't really like this.  
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.EnableAdditionalProviders(Microsoft.Diagnostics.Tracing.Session.TraceEventSession,System.String[],System.String)">
            <summary>
            Enable any additional providers specified by 'providerSpecs'.  
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.DoClrRundownForSession(System.String,System.String,PerfView.CommandLineArgs)">
            <summary>
            Activates the CLR rundown for the user session 'sessionName' with logFile 'fileName'  
            </summary>
        </member>
        <member name="M:PerfView.CommandProcessor.WaitForRundownIdle(System.Int32,System.Int32,System.String)">
            <summary>
            Currently there is no good way to know when rundown is finished.  We basically wait as long as
            the rundown file is growing.  
            </summary>
        </member>
        <member name="T:PerfView.ProviderParser">
            <summary>
            ProviderParser knows how to take a string provider specification and parse it.  
            </summary>
        </member>
        <member name="M:PerfView.ProviderParser.ParseProviderSpecs(System.String[],System.String,System.IO.TextWriter)">
            <summary>
            TODO FIX NOW document
            </summary>
        </member>
        <member name="T:PerfView.EventSourceFinder">
            <summary>
            EventSourceFinder is a class that can find all the EventSources in a file
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.FileInputAndOutput">
            <summary>
            Interaction logic for FileInputAndOutput.xaml
            
            It allows you to select a file (or directory) as input and also a file as output.   
            </summary>
            <summary>
            FileInputAndOutput
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.#ctor(System.Action{System.String,System.String})">
            <summary>
            Creates a class that will select a file (or directory if SelectingDirectories=true)
            and then call onOK, with the first argument being the input file selected and the second being the output file.
            After setting any properties, you can call Show() to actually open the dialog box.  
            </summary>
            <param name="onOK"></param>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.Show">
            <summary>
            After calling any desired properties, call this routine to display the dialog box.  
            </summary>
        </member>
        <member name="P:PerfView.Dialogs.FileInputAndOutput.CurrentDirectory">
            <summary>
            This is the directory that we currently use to populate the listbox of possible completions.  
            Note that has NOTHING to do with Environment.CurrentDirectory EXCEPT that Environment.CurrentDirectory
            is used as the initial default if it is not set before calling Show()
            
            This is intended always a valid directory (Don't assign to it unless you know this is true).  
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.GetValidDirectory(System.String)">
            <summary>
            Given a filePath, return the largest prefix that is a valid directory.  Note that
            if filePath ends in \ it tries that as a directory, but otherwise it will strip off
            the stuff after the \.  
            
            Returns the null if there is no valid directory in the path (pretty weird)
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.SetInputFileName(System.String)">
            <summary>
            Takes 'fileName' (which is a file name without a directory) and combines it with any directory currently
            in 'InputFileName' and updates it to have the new file name (but the same directory).
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.ExtensionFilter(System.String)">
            <summary>
            Returns true of 'name' ends with one of the Extensions the dialog box was told to filter on.  
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.ReplaceFileInPath(System.String,System.String)">
            <summary>
            Given a path 'fullPath' replace the file name part with 'fileName'.   
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FileInputAndOutput.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.EmptySymbolPathDialog">
            <summary>
            Dialog poped when the symbol path is empty.  This gives the user control over whether PerfView will perform network operations
            
            It is intended that this be a modal dialog (ShowDialog)
            </summary>
            <summary>
            EmptySymbolPathDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.EmptySymbolPathDialog.#ctor">
            <summary>
            The action is given a 'true' value if MSSymbols should be used.  
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.EmptySymbolPathDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.EULADialog">
            <summary>
            Interaction logic for EULADialog.xaml
            </summary>
            <summary>
            EULADialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.EULADialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.FeedbackDialog">
            <summary>
            Interaction logic for FeebackDialog.xaml
            </summary>
            <summary>
            FeedbackDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.FeedbackDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.MemoryDataDialog">
            <summary>
            Interaction logic for HeapDumpDialog.xaml
            </summary>
            <summary>
            MemoryDataDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.MemoryDataDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.ProviderBrowser">
            <summary>
            Interaction logic for ProviderBrowser.xaml
            </summary>
            <summary>
            ProviderBrowser
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.ProviderBrowser.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.SourceNameLookup">
            <summary>
            TODO FIX NOW use or remove
            </summary>
            <summary>
            SourceNameLookup
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.SourceNameLookup.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.SymbolPathDialog">
            <summary>
            Interaction logic for SymbolPathDialog.xaml
            </summary>
            <summary>
            SymbolPathDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.SymbolPathDialog.#ctor(System.String,System.String,System.Action{System.String})">
            <summary>
            Kind should be either 'symbol' or 'source' depending on which path variable to set.  
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.SymbolPathDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.UserCommandDialog">
            <summary>
            Display a dialog box for executing user commands. 
            </summary>
            <summary>
            UserCommandDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.UserCommandDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.Dialogs.UnhandledExceptionDialog">
            <summary>
            Interaction logic for UnhandledExceptionDialog.xaml
            </summary>
            <summary>
            UnhandledExceptionDialog
            </summary>
        </member>
        <member name="M:PerfView.Dialogs.UnhandledExceptionDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.ETWEventSource">
            <summary>
            The EventViewer takes a abstract EventSource and displays it.  ETWEventSource
            is the implementation of the abstract EventSource class for ETW data.  
            </summary>
        </member>
        <member name="M:PerfView.ETWEventSource.ETWEventRecord.AddField(System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.Int32},System.Text.StringBuilder)">
            <summary>
            Adds 'fieldName' with value 'fieldValue' to the output.  It either goes into a column (based on columnOrder) or it goes into
            'rest' as a fieldName="fieldValue" string.   It also updates 'columnSums' for the fieldValue for any in a true column 
            </summary>
        </member>
        <member name="M:PerfView.ETWEventSource.ETWEventRecord.PadIfNumeric(System.String)">
            <summary>
            Hack to make sort work properly most of the time.   Basically if 'fieldValue' looks like a number pad it with 
            spaces to the left to make sure it sorts like a number.   This works for numbers with 6 digits (or comma) in
            front of the decimal point.   Thus it works up to 99,999.999
            </summary>  
        </member>
        <member name="F:PerfView.ETWEventSource.EventVisitedVersion.ShouldProcess">
            <summary>
            We match start and stop opcodes.  We want to allow Start opcodes even if they are not selected to insure that
            we can compute the duration between start and stop events.  
            </summary>
        </member>
        <member name="T:PerfView.EventWindow">
            <summary>
            Interaction logic for SelectProcess.xaml
            </summary>
            <summary>
            EventWindow
            </summary>
        </member>
        <member name="M:PerfView.EventWindow.PadForColumn(System.String,System.Int32)">
            <summary>
            given the content string, and the columnIndex, return a string that is propertly padded
            so that when displayed the rows will line up by columns nicely  
            </summary>
        </member>
        <member name="M:PerfView.EventWindow.EscapeForCsv(System.String,System.String)">
            <summary>
            Returns a string that is will be exactly one field of a CSV file.  Thus it escapes , and ""
            </summary>
        </member>
        <member name="M:PerfView.EventWindow.Add(System.Collections.ObjectModel.ObservableCollection{EventSources.EventRecord},EventSources.EventRecord)">
            <summary>
            This needs to be separate routine so that the event_ local variable is a copy of the one that was passed
            </summary>
        </member>
        <member name="F:PerfView.EventWindow.m_clipboardRangeStart">
            <summary>
            If we have only two cells selected, even if they are on different rows we want to morph them
            to a single row.  These variables are for detecting this situation.  
            </summary>
        </member>
        <member name="M:PerfView.EventWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.GCHeapSimulators">
            <summary>
            GCHeapSimulators manages all GCHeapSimulator on the machine (one for each process with a GC heap).  It basically is a collection
            of the simulators organized by process.   You can enumerate them and index them by process.  
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulators.UseOnlyAllocTicks">
            <summary>
            If set (before the source is processed), indicates that only the GC Allocation Ticks (100K samples) should be used 
            in the analysis even if other object allocation events are present.   
            </summary>
        </member>
        <member name="F:PerfView.GCHeapSimulators.OnNewGCHeapSimulator">
            <summary>
            If you wish to get control when a new Heap Simulator is activated, set this.   
            </summary>
        </member>
        <member name="T:PerfView.GCHeapSimulator">
            <summary>
            GCHeapSimulator is designed to take the allocation and GC events from 'source' from process 'processID' and simulate 
            their effect on the GC heap in the process.  As events come in the 'AllObjects, GetObject, and CurrentHeapSize
            track what should be in the GC heap at that point int time.  It will also issue callbacks on every object creation
            and destruction if the client subscribes to them.  
            
            Objects in this simulator are GCHeapSimulatorObject which remember their type, 
            This class is designed to be subclassed 
            </summary>
        </member>
        <member name="M:PerfView.GCHeapSimulator.#ctor(Microsoft.Diagnostics.Tracing.TraceEventDispatcher,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,System.IO.TextWriter,System.Boolean)">
            <summary>
            Create a GC simulation using the events from 'source' for the process with process ID 'processID'.  
            The stacks associated with allocation are added to 'stackSource' (and a pseudo-frame with the type
            is added to the stacks for each allocation.   If useOnlyAllocationTicks, it will not use 
            either the etwClrProfiler or GCSampledObjectAllocation as allocation events (so you can reliably 
            get a coarse sampled simulation independent of what other events are in the trace).  
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulator.CurrentHeapSize">
            <summary>
            The size of all allocated but not collected by the GC at the current time (does not include fragmented free space).  
            </summary>
        </member>
        <member name="M:PerfView.GCHeapSimulator.GetObjectInfo(System.UInt64,System.Int32@)">
            <summary>
            Fetches the information we know about a particular object given its address in memory.  Note that our
            understanding of what generation an object is in may not be completely in sync with the GCs.  
            </summary>
        </member>
        <member name="M:PerfView.GCHeapSimulator.TrackObject(System.UInt64)">
            <summary>
            Indicates that 'objectAddress' should be tracked (so that later you can do a 'GetObjectInfo' on it.   
            Returns the current simulation object for it.  
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulator.AllObjects">
            <summary>
            Allows you to enumerate all objects on the heap at the current point in time.  
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulator.ProcessId">
            <summary>
            The ID of the process of interest.  Events from other processes are ignored.
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulator.StackSource">
            <summary>
            The stack source where allocation stacks are interned.  
            </summary>
        </member>
        <member name="F:PerfView.GCHeapSimulator.OnObjectCreate">
            <summary>
            If you are interested in hooking when objects get created, override this delegate.  It is given the object address
            and its information, and returns true if that object should be tracked (otherwise it is discarded)
            </summary>
        </member>
        <member name="F:PerfView.GCHeapSimulator.OnObjectDestroy">
            <summary>
            If you are interested in hook in when objects are destroyed, override this delegate.  I
            The callback is given 
               * the time of the GC
               * the generation being collected
               * the object address
               * The object information (where it was allocated)
            </summary>
        </member>
        <member name="P:PerfView.GCHeapSimulator.AllocateObject">
            <summary>
            You can override this function to cause the simulator to allocate subclasses 
            of GCHeapSimulatorObject so you can attach addition information to it.  
            </summary>
        </member>
        <member name="M:PerfView.GCHeapSimulator.CopyPlugToNextGen(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Takes the set of objects (a plug) in the region from 'fromPtr' to fromEnd, and relocates the objects to new address 'toPtr'.
            It also places the objects into whatever generation it is current in to m_condemedGenerationNum+1.  
            Note that while our understanding of where what generation an object is might differ from the GC's idea, (we ALWAYS promote 
            to a m_condemedGenerationNum+1 where the GC might not), this does not affect the movement/liveness calculation.  
            </summary>
        </member>
        <member name="T:PerfView.GCHeapSimulatorObject">
            <summary>
            GCHeapSimulatorObject holds all the information (Except the object ID itself) that the GCSimulation knows about an object.
            It can be subclassed so that user-defined information can be added as well. 
            </summary>
        </member>
        <member name="T:PerfView.GCPinnedObjectViewType">
            <summary>
            Represents the type of view to generated data for.
            </summary>
        </member>
        <member name="T:PerfView.PinnedObject">
            <summary>
            Represents a pinned object in the GC heap.
            </summary>
        </member>
        <member name="T:PerfView.PinningRoot">
            <summary>
            Represents a pinning root that references one or more objects in the GC heap.
            </summary>
        </member>
        <member name="T:PerfView.GCPinnedObjectAnalyzer">
            <summary>
            The class responsible for generating data for pinned object analysis.
            This analysis is based on an ETW trace and a corresponding heap snapshot.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._HeapSnapshotFilePath">
            <summary>
            The file path to the heap snapshot.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._TraceLog">
            <summary>
            The trace log representing the ETW trace.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._StackSource">
            <summary>
            The stack source that should be used when generating stacks.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._Sample">
            <summary>
            The sample to be used when generating data points.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._ProcessID">
            <summary>
            The process that we intend to analyze.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._Log">
            <summary>
            The log for diagnostic data.
            </summary>
        </member>
        <member name="F:PerfView.GCPinnedObjectAnalyzer._RootTable">
            <summary>
            The set of pinning roots and pinned objects in the heap snapshot.
            </summary>
            <remarks>
            TKey == The address of the pinned object.
            TValue == The pinning root, which also contains references to objects in the GC heap that it pins.
            </remarks>
        </member>
        <member name="M:PerfView.GCPinnedObjectAnalyzer.ExistsMatchingHeapSnapshot(System.String)">
            <summary>
            Used to determine if a matching heap snapshot file exists.
            </summary>
        </member>
        <member name="M:PerfView.GCPinnedObjectAnalyzer.GetHeapSnapshotPath(System.String)">
            <summary>
            Get the heap snapshot file path that matches the input ETL file.
            </summary>
            <remarks>
            We match the file in the same directory with the same prefix.  E.g. PerfViewData.etl.zip as the input will generate PerfViewData.gcdump.
            </remarks>
        </member>
        <member name="M:PerfView.GCPinnedObjectAnalyzer.Execute(PerfView.GCPinnedObjectViewType)">
            <summary>
            Execute the pinned object analyzer.
            </summary>
        </member>
        <member name="M:PerfView.GCPinnedObjectAnalyzer.WriteAllocationStack(System.UInt64,PerfView.PinningRoot,PerfView.PinningStackAnalysisObject)">
            <summary>
            Add a sample representing the pinned object allocation.
            </summary>
        </member>
        <member name="M:PerfView.GCPinnedObjectAnalyzer.WritePinningStacks(System.UInt64,PerfView.PinningRoot,PerfView.PinningStackAnalysisObject)">
            <summary>
            Write out a sample for each pin operation of the input object.
            </summary>
        </member>
        <member name="T:PerfView.PinningStackAnalysis">
            <summary>
            Does a GC simulation of the events in 'source' for process with id 'processID'.   It also 
            tracks GC pinning handel set operations and adds that information to the objects being
            tracked by the simulation. 
            </summary>
        </member>
        <member name="T:PerfView.PinningStackAnalysisObject">
            <summary>
            GCHeapSimulatorObject, is what we know about any object on the GC heap.  PinningAnalysis adds extra i
            nfromation to GCHeapSimulatorObject about pinning.  
            </summary>
        </member>
        <member name="T:PerfView.PinningStackAnalysisPinInfo">
            <summary>
            Information we know about one particular set operation of a pinning GC handle 
            </summary>
        </member>
        <member name="T:PerfView.StatusBar">
            <summary>
            Interaction logic for StatusBar.xaml
            </summary>
            <summary>
            StatusBar
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.Status">
            <summary>
            Report messages are short messages that are not persisted in the history, these are meant for
            messages that are not in direct response to a user command (and thus might be 'noise')
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.Log(System.String)">
            <summary>
            Logging a message on the other hand, is persisted, and can be viewed later.  These should be
            used for any messages that are in direct response to an obvious user command (Effectively 
            logging what the user did.  
            
            This can called by the worker thread, and Log() will insure that it posts the message on the GUI thread
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.LogError(System.String)">
            <summary>
            Logs an error message (logs and then beeps).  
            </summary>
            <param name="errorMessage"></param>
        </member>
        <member name="M:PerfView.StatusBar.Beep">
            <summary>
            Play a beep sound. 
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.LoggedError">
            <summary>
            Have we just logged an error (last message in status bar is an error message)
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.LogWriter">
            <summary>
            returns a TextWriter for the status log.  
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.AttachWriterToLogStream(System.IO.TextWriter)">
            <summary>
            This causes any text written to the status log to also be written to 'writer' as well.  
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.LogWindow">
            <summary>
            This fetches the window which has the log text in it 
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.OpenLog">
            <summary>
            The status bar has a log associated with it.  This opens the window (if it is not already open)
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.StartWork(System.String,System.Action,System.Action)">
            <summary>
            This starts long running work.  It is called on the GUI thread.
            Only one piece of work can be running at a time (this is simply to keep the
            model the user sees simple).  
            
            If finally_ is present, it will be run at EndWork time (But before the 
            'response' delegate passed to EndWork).   Logically it is a finally clause associated
            with the work (but not the 'response')  Unlike 'response' this action
            will occur under ALL conditions, including cancellation.   it is used for other
            GUID indications that work is in progress.  
            
            If 'finally_' is present it will be executed on the GUI thread.  
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.EndWork(System.Action)">
            <summary>
            This is used by the thread off the GUI thread to post back a response.  It also informs
            the GUI that works is done.   This should only be called from the worker thread (use
            Abort() to force an abort).  
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.AbortWork(System.Boolean)">
            <summary>
            Abort the piece of work that is in flight (if any).  It returns promptly and the abort may not
            be complete by the time it returns.   Abort will be complete when IsWorking==false.  
            
            If silent is true then no log message is sent.  Useful for 'expected' aborts which would otherwise clutter the log.  
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.DoWork(System.String,System.Action)">
            <summary>
            In the case where the work has no completion action other than updating status, this routine
            can do all the work (startWord, do work endWork)
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.IsWorking">
            <summary>
            returns true if we have started work and have not completed it. 
            </summary>
        </member>
        <member name="P:PerfView.StatusBar.IsNotWorking">
            <summary>
            returns true if we there is no pending work. 
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.ExpandSelectionByANumber(System.Windows.Controls.TextBox)">
            <summary>
            Give a textBox, expand the selection to select the whole number
            returns true if successful.  Meant to be used for TextBox doubleClick events.  
            TODO this really does not belong here. 
            </summary>
        </member>
        <member name="M:PerfView.StatusBar.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.GuiUtilities.WebBrowserWindow">
            <summary>
            Interaction logic for WebBrowserWindow.xaml
            </summary>
            <summary>
            WebBrowserWindow
            </summary>
        </member>
        <member name="F:PerfView.GuiUtilities.WebBrowserWindow.HideOnClose">
            <summary>
            If set simply hide the window rather than closing it when the user requests closing. 
            </summary>
        </member>
        <member name="M:PerfView.GuiUtilities.WebBrowserWindow.Navigate(System.String)">
            <summary>
            LIke Broswer.Navigate, but you don't have to be on the GUI thread to use it.  
            </summary>
        </member>
        <member name="M:PerfView.GuiUtilities.WebBrowserWindow.Navigate(System.Windows.Controls.WebBrowser,System.String)">
            <summary>
            A simple helper wrapper that translates some exceptions nicely.  
            </summary>
        </member>
        <member name="M:PerfView.GuiUtilities.WebBrowserWindow.Window_Closing(System.Object,System.ComponentModel.CancelEventArgs)">
            <summary>
            We hide rather than close the editor.  
            </summary>
        </member>
        <member name="M:PerfView.GuiUtilities.WebBrowserWindow.Browser_SizeChanged(System.Object,System.Windows.SizeChangedEventArgs)">
            <summary>
            The browser looses where it is when it resizes, which is very confusing to people
            Thus force a resync when the window resizes.  
            </summary>
        </member>
        <member name="M:PerfView.GuiUtilities.WebBrowserWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.GcEventWrapper">
            <summary>
            Wrapper around GCEvent for data binding (needs public properties)
            </summary>
        </member>
        <member name="T:PerfView.GcInfoView">
            <summary>
            GCInfo Panel
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.OnHelp(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Help request from Hyperlink
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.FilterEvent">
            <summary>
            Filter events according to checkboxes
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.ReasonSelectAll(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            GCReason SelctAll
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.GenerationSelectAll(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Generation SelectAll
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.UpdateEvents(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Event selection checkbox handler
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.CreateGCInfoPanel(System.Windows.Controls.TextBox)">
            <summary>
            Create GCInfo panel
            </summary>
        </member>
        <member name="M:PerfView.GcInfoView.InitHelpText">
            <summary>
            Populate help message dictionary
            </summary>
        </member>
        <member name="T:PerfView.AllocTick">
            <summary>
            Unique Allocation Tick Site: type + location
            </summary>
        </member>
        <member name="T:PerfView.AllocTickComparer">
            <summary>
            AllocTickKey comparer
            </summary>
        </member>
        <member name="T:PerfView.HeapAllocView">
            <summary>
            Displaying Allocation Tick events in DataGrid
            </summary>
        </member>
        <member name="M:PerfView.HeapAllocView.CreateHeapAllocPanel(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            Create HeapAllocView panel
            </summary>
        </member>
        <member name="T:PerfView.AllocTickConverter">
            <summary>
            DataBinding for AllocTick in DataGrid
            </summary>
        </member>
        <member name="T:PerfView.HeapEvents">
            <summary>
            All managed heap related events
            </summary>
        </member>
        <member name="F:PerfView.HeapEvents.GCFinalizersBegin">
            
        </member>
        <member name="F:PerfView.HeapEvents.FinalizeObject">
            //////////////////////////
        </member>
        <member name="T:PerfView.HeapEventData">
            <summary>
            Per event data
            </summary>
        </member>
        <member name="T:PerfView.ThreadMemoryInfoComparer">
            <summary>
            Sorting thread by name(type) and then CPU sample
            </summary>
        </member>
        <member name="T:PerfView.ThreadMemoryInfo">
            <summary>
            Per-thread data
            </summary>
        </member>
        <member name="T:PerfView.ProcessMemoryInfo">
            <summary>
            Per-process data, extension of GCProcess
            </summary>
        </member>
        <member name="M:PerfView.ProcessMemoryInfo.FilterEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Event filtering by process ID. Called in ForwardEventEnumerator::MoveNext
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:PerfView.DiagramData">
            <summary>
            Data passed to HeapDiagram
            </summary>
        </member>
        <member name="T:PerfView.BarInterval">
            <summary>
            Class for combining multiple time intervals on the same horizontal bar
            </summary>
        </member>
        <member name="T:PerfView.Renderer">
            <summary>
            Renderer: WPF Visual generation
            </summary>
        </member>
        <member name="M:PerfView.Renderer.SetBarRegion(System.Double,System.Double,System.Double)">
            <summary>
            Set horizontal bar region
            </summary>
            <param name="h">height</param>
            <param name="t0">minimum time stamp</param>
            <param name="t1">maximum time stamp</param>
        </member>
        <member name="T:PerfView.HeapDiagramGenerator">
            <summary>
            Diagram generation
            </summary>
        </member>
        <member name="T:PerfView.Metric">
            <summary>
            Metric for Metrics DataGrid
            </summary>
        </member>
        <member name="T:PerfView.HeapDiagram">
            <summary>
            HeapDiagram Panel
            </summary>
        </member>
        <member name="M:PerfView.HeapDiagram.OnZoomTo(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Zoom to time range
            </summary>
        </member>
        <member name="M:PerfView.HeapDiagram.CreateContextMenu(System.Windows.Controls.ContextMenu,System.Windows.Point,System.Windows.Point)">
            <summary>
            Create/update ContextMenu for RubbeerBand adorner
            </summary>
        </member>
        <member name="M:PerfView.HeapDiagram.OnCropDiagram(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Crop diagram to displayed time range, for performance, bigger zoom range
            </summary>
        </member>
        <member name="M:PerfView.HeapDiagram.OnUndoCrop(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Undo Crop
            </summary>
        </member>
        <member name="T:PerfView.MemoryAnalyzer">
            <summary>
            Managed Memory Analyzer main window
            </summary>
        </member>
        <member name="T:PerfView.IssueView">
            <summary>
            Issue Panel
            </summary>
        </member>
        <member name="T:PerfView.ThreadView">
            <summary>
            ThreadPanel: displaying/selecting threads based on ThreadMemoryInfo
            </summary>
        </member>
        <member name="T:PerfView.ProcInfo">
            <summary>
            Another IProcess implementation with more information (CLR version for the moment)
            </summary>
        </member>
        <member name="T:PerfView.VisualHolder">
            <summary>
            Wrapper around Visual as FrameworkElement
            </summary>
        </member>
        <member name="T:PerfView.HtmlWriter">
            <summary>
            HTML generation
            </summary>
        </member>
        <member name="T:PerfView.VisualPaginator">
            <summary>
            Wrapper Visual for XPS generation with specific page size
            </summary>
        </member>
        <member name="T:PerfView.Toolbox">
            <summary>
            Reusable helper methods
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.Stack(System.Windows.Controls.Orientation,System.Windows.UIElement,System.Windows.UIElement,System.Windows.UIElement)">
            <summary>
            Create StackPanel with two children
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.DockTopLeft(System.Windows.UIElement,System.Windows.UIElement,System.Windows.UIElement)">
            <summary>
            Create DockPanel with three children
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.DockTop(System.Windows.Controls.DockPanel,System.Windows.UIElement)">
            <summary>
            Dock top
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.DockBottom(System.Windows.Controls.DockPanel,System.Windows.UIElement)">
            <summary>
            Dock top
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.DockLeft(System.Windows.Controls.DockPanel,System.Windows.UIElement)">
            <summary>
            Dock left
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.DockRight(System.Windows.Controls.DockPanel,System.Windows.FrameworkElement)">
            <summary>
            Dock right
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.FindChild(System.Windows.Media.Visual,System.Type)">
            <summary>
            Walk Visual tree to find first child of certain type
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.WalkTree(System.Text.StringBuilder,System.Windows.Media.Visual)">
            <summary>
            Walk Visual tree for investigation
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.RightJustifyStyle(System.Windows.Style)">
            <summary>
            Create right justify style
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddButtonColumn(System.Windows.Controls.DataGrid,System.Type,System.Object,System.String,System.Windows.RoutedEventHandler)">
            <summary>
            Add Button column to DataGrid
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddColumn(System.Windows.Controls.DataGrid,System.Object,System.String,System.Boolean,System.String)">
            <summary>
            Add column to Datagrid
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddColumn(System.Windows.Controls.DataGrid,System.Object,System.String,System.Windows.Data.IValueConverter,System.Object,System.Boolean)">
            <summary>
            Add column to Datagrid
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.CreateCheckBox(System.Boolean,System.String,System.Int32,System.Int32,System.Windows.RoutedEventHandler)">
            <summary>
            Create CheckBox
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddCheckBox(System.Windows.Controls.Panel,System.Boolean,System.String,System.Int32,System.Int32,System.Windows.RoutedEventHandler)">
            <summary>
            Add CheckBox
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.CreateButton(System.String,System.Int32,System.Windows.RoutedEventHandler,System.Int32,System.Int32)">
            <summary>
            Create Button
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddButton(System.Windows.Controls.Panel,System.String,System.Int32,System.Windows.RoutedEventHandler,System.Int32,System.Int32)">
            <summary>
            Add Button
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.CreateTextBlock(System.String,System.String,System.Windows.RoutedEventHandler,System.Int32,System.Int32)">
            <summary>
            Create TextBlock with Hyperlink
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddTextBlock(System.Windows.Controls.Panel,System.String,System.String,System.Windows.RoutedEventHandler,System.Int32,System.Int32)">
            <summary>
            Add TextBlock with Hyperlink
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.UnChecked(System.Windows.Controls.Primitives.ToggleButton)">
            <summary>
            Check if a ToggleButton is not checked
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.AddItem(System.Windows.Controls.ItemsControl,System.String,System.Boolean,System.Boolean)">
            <summary>
            Add MenuItem
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.HookupVisibility(System.Windows.Controls.MenuItem,System.Windows.UIElement)">
            <summary>
            Hookup MenuItem Checked/Unchecked events to UIElement visibility
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.MakeCollapsed(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Collapse UIElement
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.MakeVisible(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Make UIElement visible
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.IsClr(System.String)">
            <summary>
            Check for CLR modules
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.IsMscorlib(System.String)">
            <summary>
            Check for BCL modules
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.GetClrProcesses(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,System.Boolean@)">
            <summary>
            Get processes with CLR loaded
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.SelectClrProcess(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,System.Action{System.Collections.Generic.List{PerfView.IProcess}})">
            <summary>
            Process selection dialog box with CLR processes only, extra column for CLR version
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.SaveAsPng(System.Windows.Media.Visual,System.Int32,System.Int32,System.String)">
            <summary>
            Save Visual as PNG file
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.SaveAsXps(System.Windows.Media.Visual,System.Int32,System.Int32,System.String)">
            <summary>
            Save Visual as XPS file, may be slow
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.Wrap(System.Windows.Controls.Panel,System.String)">
            <summary>
            Wrap around Panel with top-left border, with a label as Tooltip
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.GetSaveFileName(System.String,System.String,System.String)">
            <summary>
            FileSaveAs dialog box
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.GetMethodName(Microsoft.Diagnostics.Tracing.Etlx.TraceLog,Microsoft.Diagnostics.Tracing.Etlx.CodeAddressIndex)">
            <summary>
            Get method name from CodeAddressIndex
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.CreateStackSource(PerfView.PerfViewFile,System.String,System.Int32,System.IO.TextWriter,System.Boolean)">
            <summary>
            Create StackSource from supported named 'stream's, with filtering
            Check ETLPerfViewData.OpenStackSourceImpl for real implementation
            </summary>
        </member>
        <member name="M:PerfView.Toolbox.StackWindowTo(PerfView.PerfViewFile,System.Windows.Window,PerfView.StackWindow@,Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.String,System.Double,System.Double)">
            <summary>
            Open/Reopen StackWindow for a process and sets/resets its time range
            </summary>
        </member>
        <member name="T:PerfView.IProcessConverter">
            <summary>
            DataBinding for ProcInfo in DataGrid
            </summary>
        </member>
        <member name="T:PerfView.AddExtra">
            <summary>
            Add extra drawing to RubberBand adorner
            </summary>
        </member>
        <member name="T:PerfView.RubberBandAdorner">
            <summary>
            Rubber Band implemented as Adorner
            </summary>
        </member>
        <member name="M:PerfView.RubberBandAdorner.OnMouseLeftButtonDown(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Left butto down: start rubber banding
            </summary>
        </member>
        <member name="M:PerfView.RubberBandAdorner.OnMouseLeftButtonUp(System.Object,System.Windows.Input.MouseButtonEventArgs)">
            <summary>
            Left button up: end rubber banding
            </summary>
        </member>
        <member name="M:PerfView.RubberBandAdorner.OnCanvasMouseMove(System.Object,System.Windows.Input.MouseEventArgs)">
            <summary>
            Mouse move, update rubber banding if started
            </summary>
        </member>
        <member name="M:PerfView.RubberBandAdorner.OnRender(System.Windows.Media.DrawingContext)">
            <summary>
            Generate Visual for rubber band, with extra drawing through delegate
            </summary>
        </member>
        <member name="T:PerfView.EventFilter">
            <summary>
            Filter for TraceEvent
            </summary>
        </member>
        <member name="T:PerfView.StackWindowHook">
            <summary>
            Hook up StackWindow
            </summary>
        </member>
        <member name="T:PerfView.GridRow">
            <summary>
            A panel as a row in a Grid panel, with splitter and visibility control
            </summary>
        </member>
        <member name="M:PerfView.GridRow.HookupVisibility(System.Windows.Controls.MenuItem)">
            <summary>
            Hookup MenuItem Checked/Unchecked events to UIElement visibility
            </summary>
        </member>
        <member name="M:PerfView.GridRow.MakeCollapsed(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Collapse UIElement
            </summary>
        </member>
        <member name="M:PerfView.GridRow.MakeVisible(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Make UIElement visible
            </summary>
        </member>
        <member name="T:PerfView.StackSourceBuilder">
            <summary>
            StackSource building by adding samples
            </summary>
        </member>
        <member name="T:PerfView.ColorScheme">
            <summary>
            Set of brushes, pens, for showing one generation of GC
            </summary>
        </member>
        <member name="M:PerfView.GraphWalker.AddTarget(Graphs.NodeIndex)">
            <summary>
            Add target node to search for
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:PerfView.GraphWalker.AddSource(Graphs.NodeIndex)">
            <summary>
            Add source node to start search
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:PerfView.GraphWalker.VisitChild(Graphs.NodeIndex)">
            <summary>
            
            </summary>
            <param name="c"></param>
            <returns>true on first visit of a target node</returns>
        </member>
        <member name="M:PerfView.GraphWalker.WalkGraph(Graphs.Graph)">
            <summary>
            Breadth-first walk from source nodes
            </summary>
            <param name="graph"></param>
        </member>
        <member name="M:PerfView.IProcessForProcessInfo.ParentDepth(PerfView.ProcessInfo)">
            <summary>
            Find the depth of a process (0 means I have no parent).  
            </summary>
        </member>
        <member name="T:PerfView.RunCommandDialog">
            <summary>
            Interaction logic for RunCommandDialog.xaml
            </summary>
            <summary>
            RunCommandDialog
            </summary>
        </member>
        <member name="M:PerfView.RunCommandDialog.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.SelectProcess">
            <summary>
            Interaction logic for SelectProcess.xaml
            </summary>
            <summary>
            SelectProcess
            </summary>
        </member>
        <member name="M:PerfView.SelectProcess.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:PerfView.HeapDumper.DumpGCHeap(System.Int32,System.String,System.IO.TextWriter,System.String)">
            <summary>
            Take a heap dump from a live process. 
            </summary>
        </member>
        <member name="M:PerfView.HeapDumper.ForceGC(System.Int32,System.IO.TextWriter)">
            <summary>
            Force a GC on process processID
            </summary>
        </member>
        <member name="M:PerfView.HeapDumper.DumpGCHeap(System.String,System.String,System.IO.TextWriter,System.String)">
            <summary>
            Take a heap dump from a process dump
            </summary>
        </member>
        <member name="M:PerfView.HeapDumper.GetProcessID(System.String)">
            <summary>
            Given a name or a process ID, return the process ID for it.  If it is a name
            it will return the youngest process ID for all processes with that
            name.   Returns a negative ID if the process is not found.  
            </summary>
        </member>
        <member name="M:PerfView.HeapDumper.GetArchForProcess(System.Int32)">
            <summary>
            Returns the x86 or AMD64 that indicates the architecture of the process with 'processID'
            </summary>
        </member>
        <member name="T:PerfView.ObjectViewer">
            <summary>
            ObjectViewer is PerFView's view that displays individual object in the heap graph.   It is a TreeeViewGrid 
            that is wired up to get its data from the 'graph' and 'refGraph' starting with a list of 'focus nodes' as
            the root of the tree.  
            </summary>
            <summary>
            ObjectViewer
            </summary>
        </member>
        <member name="T:PerfView.ObjectViewer.ObjectViewerTreeViewController">
            <summary>
            ObjectViewerTreeViewController is the thing that describes the tree the viewer will display
            Thus it tells you how to get the root node and for each node how to get its children.   
            It also tells how to get the column data to display.   We simply wire this up to the
            graph.   We do this by creating ITreeViewControllerNode that represent nodes in the 
            tree which hold a NodeIndex that lets us get at all addition information about the node.  
            </summary>
        </member>
        <member name="T:PerfView.ObjectViewer.ObjectViewerTreeViewController.ITreeViewControllerNode">
            <summary>
            The graph does not have object but rather indexes that represent nodes. 
            We fix this mismatch by creating ITreeViewControllerNode which 'wraps' the NodeIndex
            but also remembers enough to create a useful name for the node.  
            </summary>
        </member>
        <member name="M:PerfView.ObjectViewer.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.TreeViewGrid">
            <summary>
            TreeViewGrid if a reusable, multi-column grid view where the first column can be a tree.  That first column can be
            expanded like a tree view and the other columns work as expected. 
            
            All of this is controlled by the ITreeViewController interface.  By implementing this interface, and then passing
            an instance of this interface to SetController, you wire up data to the TreeViewGrid.  
            </summary>
            <summary>
            TreeViewGrid
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.SelectedNode">
            <summary>
            Gets the object (the model   Returns null if there is no selected nodes. 
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.SetController(PerfView.ITreeViewController)">
            <summary>
            Typically the GUI instantiates the TreeViewGrid as part of some XAML.   However to do its job that
            object needs to know what data it is operating on.  This is what 'SetController' does.   By defining
            an object implementing ITreeViewController and passing it to this method, you populate the TreeViewGrid
            with data.  
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.CompressContent(System.String)">
            <summary>
            Tries to make content smaller for cut and paste
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.PadForColumn(System.String,System.Int32)">
            <summary>
            given the content string, and the columnIndex, return a string that is propertly padded
            so that when displayed the rows will line up by columns nicely  
            </summary>
        </member>
        <member name="F:PerfView.TreeViewGrid.m_clipboardRangeStart">
            <summary>
            If we have only two cells selected, even if they are on differnet rows we want to morph them
            to a single row.  These variables are for detecting this situation.  
            </summary>
        </member>
        <member name="T:PerfView.TreeViewGrid.TreeViewGridNode">
            <summary>
            This is basically a TreeViewGridNode with extra state (state of expand boxes) associated needed for the viewer 
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.IsExpanded">
            <summary>
            Is the node expanded or not.  
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.Name">
            <summary>
            The name of the node in the tree
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.IndentedName">
            <summary>
            This is IndentString followed by the display name.   It is what the view binds to (what is desiplayed in the Name column)
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.IndentString">
            <summary>
            Creates a string that has spaces | and + signs that represent the indentation level 
            for the tree node.  (Called from XAML)
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.HasChildren">
            <summary>
            Does this node have any children (invisible (unexpanded) children count))
            </summary>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.VisibleChildren">
            <summary>
            Returns the list of code:TreeViewGridNode associated with the children of this node (thus invisible nodes are not present).   
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.TreeViewGridNode.ExpandToDepth(System.Int32,System.Boolean)">
            <summary>
            Set 'IsExpanded of all nodes to a certain depth.  
            </summary>
            <param name="maxDepth">Maximum depth to expand</param>
            <param name="expandGraphNodes">If true graph nodes (which are not guaranteed to terminate) are expanded. </param>
        </member>
        <member name="P:PerfView.TreeViewGrid.TreeViewGridNode.MyIndex">
            <summary>
            Returns the sampleIndex in the flattened tree (m_flattenedTree) of this tree node.  
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.TreeViewGridNode.MakeChildren">
            <summary>
            An Unexpanded TreeViewGridNode does not have any children even if the Data (TreeViewGridNode) does
            This routine will make the necessary children (it is part of expanding the node).  
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.TreeViewGridNode.CopyExpandedStateForNode(System.Collections.Generic.List{PerfView.TreeViewGrid.TreeViewGridNode},System.Int32,PerfView.ObservableCollectionEx{PerfView.TreeViewGrid.TreeViewGridNode},System.Int32)">
            <summary>
            It is assumed that the node oldFlattenedTree[oldIndex] and newFlattenedTree[newIndex] correspond 
            to one another (have the same path to root) 
            Copies the expandedness of the node 'oldFlattenedTree[oldIndex]' to the new node at 
            newFlattenedTree[newIndex], as well as all the state for child node.  
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.TreeViewGridNode.FindChild(PerfView.ObservableCollectionEx{PerfView.TreeViewGrid.TreeViewGridNode},PerfView.TreeViewGrid.TreeViewGridNode,System.Int32,System.String)">
            <summary>
            Given a node == flattenedTree[sampleIndex] find the sampleIndex in flattenedTree of a child with Name == 'name'
            </summary>
        </member>
        <member name="M:PerfView.TreeViewGrid.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.ITreeViewController">
            <summary>
            A TreeViewContoller allow contains all the necessary callback that the TreeView needs to perform its job.
            This is what hooks up the TreeView to its model.   Basically it lets you define what the name of
            each node of the tree is as well as how to get the children of a node (as well as the root node).  
            
            It also lets you get a the column names and values.    Note that what node is represented by is
            completely arbitrary (it can be any object).  All that is necessary is that implementer of this
            interface know what to do with that object to get the necessary data.  
            </summary>
        </member>
        <member name="T:PerfView.OtherSources.TextStackSource">
            <summary>
            Takes an arbitrary text file and turns it into a stack source where each line is a frame (and there is no depth to the stacks).  
            Useful for histograms and diffs.  
            </summary>
        </member>
        <member name="F:PerfView.OtherSources.TextStackSource.StackForLine">
            <summary>
            Allows more complete control over what gets emitted for a particular line.   You get the line
            as well as an Interner (so you can created Frames and callStacks, and you just return what you want)
            </summary>
        </member>
        <member name="T:PerfView.PerfViewTreeItem">
            <summary>
            PerfViewTreeItem is a common base class for something that can be represented in the 
            TreeView GUI.  in particular it has a name, and children.   This includes both
            file directories as well as data file (that might have multiple sources inside them)
            </summary>
        </member>
        <member name="P:PerfView.PerfViewTreeItem.Name">
            <summary>
            The name to place in the treeview (should be short).  
            </summary>
        </member>
        <member name="P:PerfView.PerfViewTreeItem.Children">
            <summary>
            If the entry should have children in the TreeView, this is them.
            </summary>
        </member>
        <member name="P:PerfView.PerfViewTreeItem.FilePath">
            <summary>
            All items have some sort of file path that is associated with them.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewTreeItem.Open(System.Windows.Window,PerfView.StatusBar,System.Action)">
            <summary>
            Open the file (This might be expensive (but maybe not).  It should not be run on
            the GUI thread.  This should populate the Children property if that is appropriate.  
            
            if 'doAfter' is present, it will be run after the window has been opened.   It is always
            executed on the GUI thread.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewTreeItem.Close">
            <summary>
            Once something is opened, it should be closed.  
            </summary>
        </member>
        <member name="P:PerfView.PerfViewTreeItem.Icon">
            <summary>
            The Icon to show next to the entry.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewDirectory.Open(System.Windows.Window,PerfView.StatusBar,System.Action)">
            <summary>
            Open the file (This might be expensive (but maybe not).  This should populate the Children property 
            too.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewDirectory.Close">
            <summary>
            Close the file
            </summary>
        </member>
        <member name="M:PerfView.PerfViewDirectory.GetDirEntry(System.String)">
            <summary>
            Gets a cache entry, nulls it out if it is out of date.  
            </summary>
        </member>
        <member name="T:PerfView.PerfViewTreeGroup">
            <summary>
            A PerfViewTreeGroup simply groups other Items.  Thus it has a name, and you use the Children
            to add Child nodes to the group.  
            </summary>
        </member>
        <member name="T:PerfView.PerfViewFile">
            <summary>
            PerfViewData is an abstraction of something that PerfViewGui knows how to display.   It is 
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.Get(System.String,PerfView.PerfViewFile)">
            <summary>
            Get does not actually open the file (which might be expensive).   It also does not
            populate the children for the node (which again might be expensive).  Instead it 
            just looks at the file name).   It DOES however determine how this data will be
            treated from here on (based on file extension or an explicitly passed template parameter.
            
            Get implements interning, so if you Get the same full file path, then you will get the
            same PerfViewDataFile structure. 
            
            After you have gotten a PerfViewData, you use instance methods to manipulate it
            
            This routine throws if the path name does not have a suffix we understand.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.TryGet(System.String,PerfView.PerfViewFile)">
            <summary>
            Tries to to a 'Get' operation on filePath.   If format == null (indicating
            that we should try to determine the type of the file from the file suffix) and 
            it does not have a suffix we understand, then we return null.   
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.GetTemplateForExtension(System.String)">
            <summary>
            Logs the fact that the GUI should call a user defined method when a file is opened.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.OnOpenFile(System.String)">
            <summary>
            Declares that the user command 'userCommand' (that takes one string argument) 
            should be called when the file is opened.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.DeclareFileView(System.String,System.String)">
            <summary>
            Declares that the file should have a view called 'viewName' and the user command
            'userCommand' (that takes two string arguments (file, viewName)) should be called 
            when that view is opened 
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.GetFileNameWithoutExtension(System.String)">
            <summary>
            Retrieves the base file name from a PerfView data source's name.
            </summary>
            <example>
            GetBaseName(@"C:\data\foo.bar.perfView.xml.zip") == "foo.bar"
            </example>
            <param name="filePath">The path to the data source.</param>
            <returns>The base name, without extensions or path, of <paramref name="filePath"/>.</returns>
        </member>
        <member name="M:PerfView.PerfViewFile.ChangeExtension(System.String,System.String)">
            <summary>
            Change the extension of a PerfView data source path.
            </summary>
            <param name="filePath">The path to change.</param>
            <param name="newExtension">The new extension to add.</param>
            <returns>The path to a file with the same directory and base name of <paramref name="filePath"/>, 
            but with extension <paramref name="newExtension"/>.</returns>
        </member>
        <member name="P:PerfView.PerfViewFile.InitiallyIncludedProcesses">
            <summary>
            Gets or sets the processes to be initially included in stack views. The default value is null. 
            The names are not case sensitive.
            </summary>
            <remarks>
            If this is null, a dialog will prompt the user to choose the initially included processes
            from a list that contains all processes from the trace.
            If this is NOT null, the 'Choose Process' dialog will never show and the initially included
            processes will be all processes with a name in InitiallyIncludedProcesses.
            </remarks>
            <example>
            Let's say these are the processes in the trace: devenv (104), PerfWatson2, (67) devenv (56)
            and InitiallyIncludedProcesses = ["devenv", "vswinexpress"].
            When the user opens a stack window, the included filter will be set to "^Process32% devenv (104)|^Process32% devenv (56)"
            </example>
        </member>
        <member name="P:PerfView.PerfViewFile.SupportsProcesses">
            <summary>
            If the stack sources have their first tier being the Process, then SupportsProcesses should be true.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.GetProcesses(System.IO.TextWriter)">
            <summary>
            If the source logs data from multiple processes, this gives a list
            of those processes.  Returning null means you don't support this.  
            
            This can take a while.  Don't call on the GUI thread.  
            </summary>
        </member>
        <member name="P:PerfView.PerfViewFile.FormatName">
            <summary>
            The name of the file format.
            </summary>
        </member>
        <member name="P:PerfView.PerfViewFile.FileExtensions">
            <summary>
            The file extensions that this format knows how to read.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.OpenImpl(System.Windows.Window,PerfView.StatusBar)">
            <summary>
            Implements the open operation.   Executed NOT on the GUI thread.   Typically returns null
            which means the open is complete.  If some operation has to be done on the GUI thread afterward
            then  action(doAfter) continuation is returned.  This function is given an addition action 
            that must be done at the every end.   
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.FirstAction(PerfView.StackWindow)">
            <summary>
            Allows you to do a firt action after everything is done.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewFile.OpenStackSourceImpl(System.IO.TextWriter)">
            <summary>
            Simplified form, you should implement one overload or the other.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:PerfView.PerfViewFile.GetProcessFromStack(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.Collections.Generic.Dictionary{Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,PerfView.IProcessForStackSource},System.Collections.Generic.List{PerfView.IProcess})">
            <summary>
            Gets the process from the stack.  It assumes that the stack frame closest to the root is the process
            name and returns an IProcess representing it.  
            </summary>
        </member>
        <member name="T:PerfView.PerfViewHtmlReport">
            <summary>
            Represents a report from an ETL file that can be viewed in a web browsers.  Subclasses need 
            to override OpenImpl().  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewHtmlReport.DoCommand(System.String,PerfView.StatusBar)">
            <summary>
            You can make Command:XXXX urls which come here when users click on them.   
            Returns an  error message (or null if it succeeds).  
            </summary>
        </member>
        <member name="T:PerfView.PerfViewProcesses">
            <summary>
            Used to Display Processes Summary 
            </summary>
        </member>
        <member name="M:PerfView.PerfViewProcesses.DoCommand(System.String,PerfView.StatusBar)">
            <summary>
            Takes in either "processes" or "module" which will make a csv of their respective format
            </summary>
        </member>
        <member name="M:PerfView.PerfViewProcesses.MakeProcessesCsv(System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Etlx.TraceProcess},System.String)">
            <summary>
            Makes a csv file of the contents or processes at the filepath. 
            Headers to csv are  Name,ID,Parent_ID,Bitness,CPUMsec,AveProcsUsed,DurationMSec,StartMSec,ExitCode,CommandLine
            </summary>
        </member>
        <member name="M:PerfView.PerfViewProcesses.MakeModuleCsv(System.Collections.Generic.List{Microsoft.Diagnostics.Tracing.Etlx.TraceProcess},System.String)">
            <summary>
            Makes a Csv at filepath
            </summary>
        </member>
        <member name="F:PerfView.PerfViewProcesses.m_processes">
            <summary>
            All the processes in this view.  
            </summary>
        </member>
        <member name="T:PerfView.PerfViewHeapSnapshots">
            <summary>
            Represents all the heap snapshots in the trace
            </summary>
        </member>
        <member name="M:PerfView.PerfViewHeapSnapshots.Open(System.Windows.Window,PerfView.StatusBar,System.Action)">
            <summary>
            Open the file (This might be expensive (but maybe not).  This should populate the Children property 
            too.  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewHeapSnapshots.Close">
            <summary>
            Close the file
            </summary>
        </member>
        <member name="T:PerfView.PerfViewHeapSnapshot">
            <summary>
            Represents a single heap snapshot in a ETL file (currently only JScript).  
            </summary>
        </member>
        <member name="M:PerfView.PerfViewHeapSnapshot.#ctor(PerfView.ETLPerfViewData,System.Int32,System.String,System.Double,System.String)">
            <summary>
            snapshotKinds should be .NET or JS
            </summary>
        </member>
        <member name="T:PerfView.CSVPerfViewData">
            <summary>
            These are the data Templates that PerfView understands.  
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.GetHeap(System.UInt64,System.Collections.Generic.Dictionary{System.UInt64,System.Collections.Generic.Dictionary{System.UInt64,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample}},System.Collections.Generic.Dictionary{System.UInt64,Microsoft.Diagnostics.Tracing.Stacks.StackSourceSample}@,System.UInt64@)">
            <summary>
            Implements a simple one-element cache for find the heap to look in.  
            </summary>
        </member>
        <member name="T:PerfView.ETLPerfViewData.MemState">
            <summary>
            Class keeps track of the memory state given virtual allocs.  Basically you have to model what memory is allocated 
            </summary>
        </member>
        <member name="P:PerfView.ETLPerfViewData.MemState.TotalMem">
            <summary>
            This routine is only used in asserts.   It represents the total amount of net memory that has been
            committed by all the VirtualAllocs/Frees that have occurred so far.  
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.MemState.Update(System.UInt64,System.Int64,System.Boolean,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,System.Action{System.Int64,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex})">
            <summary>
            updates the memory state of [startAddr, startAddr+length) to be either allocated or free (based on 'isAlloc').  
            It returns the amount of memory delta (positive for allocation, negative for free).
            
            What makes this a pain is VirtuaAlloc regions can overlap (you can 'commit' the same region multiple times, or
            free just a region within an allocation etc).   
            
            Thus you have to keep track of exactly what is allocated (we keep a sorted list of regions), and do set operations
            on these regions.   This is what makes it non-trivial.  
            
            if 'isAlloc' is true, then allocStack should be the stack at that allocation.  
            
            'callback' is called with two parameters (the net memory change (will be negative for frees), as well as the call
            stack for the ALLOCATION (even in the case of a free, it is the allocation stack that is logged).   
            
            If an allocation overlaps with an existing allocation, only the NET allocation is indicated (the existing allocated
            region is subtracted out.   This means is is the 'last' allocation that gets 'charged' for a region.
            
            The main point, however is that there is no double-counting and get 'perfect' matching of allocs and frees. 
            
            There may be more than one callback issued if the given input region covers several previously allocated regions
            and thus need to be 'split up'.  In the case of a free, several callbacks could be issued because different 
            allocation call stacks were being freed in a single call.  
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.MemState.ExpandSearchTable">
            <summary>
            Allocate a new search table that has all the regions in it with not chaining necessary.   
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.MemState.Region.#ctor(System.UInt64,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,PerfView.ETLPerfViewData.MemState.Region)">
            <summary>
            Create an allocation region starting at 'startAddr' allocated at 'allocStack'
            </summary>
        </member>
        <member name="F:PerfView.ETLPerfViewData.MemState.m_searchTable">
            <summary>
            The basic data structure here is a linked list where each element is ALSO in this GrowableArray of
            entry points into that list.   This array of entry points is SORTED, so we can do binary search to 
            find a particular entry in log(N) time.   However we want to support fast insertion (and I am too
            lazy to implement a self-balancing tree) so when we add entries we add them to the linked list but
            not necessarily to this binary search table.   From time to time we will 'fixup' this table to 
            be perfect again.   
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.LookupSymbolsForModule(System.String,System.IO.TextWriter,System.Int32)">
            <summary>
            Find symbols for the simple module name 'simpleModuleName.  If 'processId' is non-zero then only search for modules loaded in that
            process, otherwise look systemWide.  
            </summary>
        </member>
        <member name="M:PerfView.ETLPerfViewData.HasVSEvents(Microsoft.Diagnostics.Tracing.Etlx.TraceLog)">
            <summary>
            See if the log has events from VS providers.  If so we should register the VS providers. 
            </summary>
        </member>
        <member name="M:PerfView.VmmapPerfViewFile.VMMapStackSource.AddToSource(PerfView.VmmapPerfViewFile.MemoryNode,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex)">
            <summary>
            Add all the nodes represented by 'node' to the source.  'parentStack' is the
            stack that represents the parent of 'node' (thus the top node is Invalid, 
            which represents the empty stack)
            </summary>
        </member>
        <member name="M:PerfView.VmmapPerfViewFile.VMMapStackSource.AddDirPathNodes(System.String,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,System.Boolean,PerfView.VmmapPerfViewFile.UseType)">
            <summary>
            Adds nodes for each parent directory that has more than one 'child' (its count is different than it child) 
            </summary>
        </member>
        <member name="T:PerfView.HeapDumpPerfViewFile.UnreachableCacheEntry">
            <summary>
            These hold stacks which we know they either have an '[not reachable from roots]' or not
            </summary>
        </member>
        <member name="M:PerfView.HeapDumpPerfViewFile.IsUnreachable(Microsoft.Diagnostics.Tracing.Stacks.StackSource,Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,PerfView.HeapDumpPerfViewFile.UnreachableCacheEntry[],System.Int32)">
            <summary>
            Returns true if 'stackIdx' is reachable from the roots (that is, it does not have '[not reachable from roots]' as one
            of its parent nodes.    'cache' is simply an array used to speed up this process because it remembers the answers for
            nodes up the stack that are likely to be used for the next index.   
            </summary>
        </member>
        <member name="T:PerfView.TypeNameSymbolResolver">
            <summary>
            A simple helper class that looks up symbols for Project N GCDumps 
            </summary>
        </member>
        <member name="M:PerfView.TypeNameSymbolResolver.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Create a new symbol resolver.  You give it a context file path (PDBS are looked up next to this if non-null) and
            a text writer in which to write symbol diagnostic messages.  
            </summary>
        </member>
        <member name="M:PerfView.ScenarioSetPerfViewFile.AddScenariosToDictionary(System.String,System.String,System.String,System.String,System.Collections.Generic.Dictionary{System.String,System.String},System.IO.TextWriter,System.String)">
            <summary>
            Search for scenario data files matching a pattern, and add them to a dictionary.
            </summary>
            <param name="filePattern">The wildcard file pattern to match. Must not be null.</param>
            <param name="namePattern">The pattern by which to name scenarios. If null, defaults to "scenario $1".</param>
            <param name="includePattern">If non-null, a pattern which must be matched for the scenario to be added</param>
            <param name="excludePattern">If non-null, a pattern which if matched causes the scenario to be excluded</param>
            <param name="dict">The dictionary to which to add the scenarios found.</param>
            <param name="log">A log file to write log messages.</param>
            <param name="baseDir">
            The directory used to resolve relative paths.
            Defaults to the directory of the XML file represented by this ScenarioSetPerfViewFile.
            </param>
        </member>
        <member name="M:PerfView.ScenarioSetPerfViewFile.DeserializeConfig(System.Xml.XmlReader,System.IO.TextWriter)">
            <summary>
            Deserialize a scenario XML config file.
            </summary>
            <param name="reader">The XmlReader containing the data to deserialize.</param>
            <param name="log">The TextWriter to log output to.</param>
            <returns>A Dictionary mapping scenario names to .perfView.xml(.zip) data file paths.</returns>
            <remarks>
            Scenario XML config files contain a ScenarioSet root element. That element contains
            one or more Scenarios elements. A Scenarios element has two attributes: "files" is a required
            filename pattern, and namePattern is a pattern by which to name the scenario.
            
            files is a required attribute specifying where to find the data files for the scenario(s). Wildcards
            are acceptable - any files matched by the wildcard will be added to the scenario set. All paths are
            relative to the location of the XML config file.
            
            namePattern can contain substitutions as specified in Regex.Replace. Each * in the wildcard
            pattern will be converted to an appropriate capturing group. If no wildcards are specified, $1 will be
            set to the base name of the data file as specified by <see cref="M:PerfView.PerfViewFile.GetFileNameWithoutExtension(System.String)"/>.
            
            files is a required attribute. namePattern is optional, and defaults to "scenario $1".
            
            If multiple scenarios have the same name, scenarios later in the file will override scenarios
            earlier in the file.
            </remarks>
            <example>
            Example config file:
            <ScenarioSet>
            <Scenarios files="*.perfView.xml.zip" namePattern="Example scenario [$1]" />
            <Scenarios files="foo.perfView.xml.zip" namePattern="Example scenario [baz]" />
            </ScenarioSet>
            
            Files in the directory:
            foo.perfView.xml.zip
            bar.perfView.xml.zip
            baz.perfView.xml.zip
            
            Return value:
            "Example scenario [foo]" => "foo.perfView.xml.zip"
            "Example scenario [bar]" => "bar.perfView.xml.zip"
            "Example scenario [baz]" => "foo.perfView.xml.zip"
            </example>
        </member>
        <member name="T:PerfView.DiagSessionPerfViewFile">
            <summary>
            Class to represent the Visual Studio .diagsesion file format that is defined
            as part of Microsoft.DiagnosticsHub.Packaging
            </summary>
        </member>
        <member name="M:PerfView.DiagSessionPerfViewFile.GetLocalFilePath(Microsoft.DiagnosticsHub.Packaging.InteropEx.DhPackage,DiagnosticsHub.Packaging.Interop.ResourceInfo,System.String)">
            <summary>
            Gets a new local file path for the given resource, extracting it from the .diagsession if required
            </summary>
            <param name="package">The diagsession package object</param>
            <param name="resource">The diagsession resource object</param>
            <param name="fileExtension">The final extension to use</param>
            <returns>The full local file path to the resource</returns>
        </member>
        <member name="M:PerfView.DiagSessionPerfViewFile.AddResourcesAsChildren(PerfView.StatusBar,Microsoft.DiagnosticsHub.Packaging.InteropEx.DhPackage,System.String,System.String,System.Func{System.String,PerfView.PerfViewFile})">
            <summary>
            Adds child files from resources in the DhPackage
            </summary>
        </member>
        <member name="M:PerfView.ScreenShot.TakeDesktopScreenShot(System.String)">
            <summary>
            Take a screenshot of the entire desktop. 
            </summary>
        </member>
        <member name="M:PerfView.ScreenShot.TakeScreenShotOfVisual(System.String,System.Windows.Window)">
            <summary>
            Take a screenshot of a particular window (WPF visual)
            </summary>
        </member>
        <member name="T:PerfView.ServerRequestScenarioConfiguration">
            <summary>
            ServerRequestScenarioConfiguration is an implementation of the ScenarioConfiguration abstract class that allows
            ComputingResourceStateMachine to track resources according to ASP.NET or WCF requests.
            
            Its job is to keep track of what requests are in flight and what threads
            </summary>
        </member>
        <member name="T:PerfView.ServerRequestComputer">
            <summary>
            Represents the state machine that encapsulates a set of server requests.
            </summary>
        </member>
        <member name="M:PerfView.ServerRequestComputer.RegisterEventHandlers(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Execute the server request computer.
            </summary>
        </member>
        <member name="M:PerfView.ServerRequestComputer.GetOrCreateASPNetServerRequest(PerfView.RequestKey,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.String)">
            <summary>
            retrieves the ASP.NET request with ID 'requestKey'.  If it does not exist it is created with the url 'url' 
            (you should pass 'unknown' if you don't know it).   It also marks 'thread' to point at this new request
            and insures that no other thread is pointing at it.   This routine never returns null. 
            </summary>
        </member>
        <member name="M:PerfView.ServerRequestComputer.GetOrCreateWCFServerRequest(PerfView.RequestKey,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,System.Guid)">
            <summary>
            Gets a WCF request for the request with ID 'requestKey'.  Also marks 'thread' as pointing to this request.   
            If 'aspNetRequestId' is non-empty it attempts to make a new request with that ASP.NET request.  This can
            fail, in which case null is returned.  
            </summary>
        </member>
        <member name="M:PerfView.ServerRequestComputer.RemoveWCFServerRequest(PerfView.RequestKey,PerfView.ASPNetServerRequest)">
            <summary>
            Remove the WCF server request with id 'requestKey'  Since there an be several requests
            with this same ID, also supply the ASP.NET Request context.   Note that it will remove
            all requests until it finds 'aspNetRequest' (so if events were missing, the alogrithm is
            robust (it cleans up).  If 'thread' is non-null, then update that thread to 
            </summary>
        </member>
        <member name="F:PerfView.ServerRequestComputer.m_ThreadStateMap">
            <summary>
            Maps thread Indexes to their current request.   Can also clear the state of any thread currently pointing at a particular request.  
            </summary>
        </member>
        <member name="F:PerfView.ServerRequestComputer.m_aspNetServerRequests">
            <summary>
            The map of ASP.NET request ids to ASP.NET request objects.
            </summary>
        </member>
        <member name="F:PerfView.ServerRequestComputer.m_wcfServerRequests">
            <summary>
            The map of WCF request ids to WCF request objects.
            </summary>
        </member>
        <member name="T:PerfView.ServerRequestThreadState">
            <summary>
            The base class for thread state associated with a server request.
            </summary>
        </member>
        <member name="P:PerfView.ServerRequestThreadState.Request">
            <summary>
            The request currently associated with the thread.
            </summary>
        </member>
        <member name="M:PerfView.ServerRequestThreadState.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Computes that part of the frame from the root of app processes up to (but not including)
            the thread frame.   
            </summary>
        </member>
        <member name="T:PerfView.ServerRequest">
            <summary>
            The base class for all request types.
            </summary>
            <remarks>
            This class needs to exist such that we don't have to keep creating thread state objects when we clear a request off of a thread.
            </remarks>
        </member>
        <member name="M:PerfView.ServerRequest.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack index for the group of all requests.
            </summary>
        </member>
        <member name="P:PerfView.ServerRequest.RequestID">
            <summary>
            The unique id of the request.
            </summary>
        </member>
        <member name="T:PerfView.ASPNetServerRequest">
            <summary>
            Represents a server-side ASP.NET request.  
            </summary>
        </member>
        <member name="P:PerfView.ASPNetServerRequest.RequestUrl">
            <summary>
            The request url.
            </summary>
        </member>
        <member name="P:PerfView.ASPNetServerRequest.WCFServerRequests">
            <summary>
            Get the list of WCF server-side requests spawned by this ASP.NET request.
            </summary>
        </member>
        <member name="M:PerfView.ASPNetServerRequest.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack index for the current request.
            </summary>
        </member>
        <member name="M:PerfView.ASPNetServerRequest.ToString">
            <summary>
            Get a displayable string for the request.
            </summary>
        </member>
        <member name="F:PerfView.ASPNetServerRequest.m_WCFServerRequests">
            <summary>
            The list of WCF server-side requests spawned by this ASP.NET request.
            </summary>
        </member>
        <member name="T:PerfView.WCFServerRequest">
            <summary>
            Represents a server-side WCF request.
            </summary>
        </member>
        <member name="P:PerfView.WCFServerRequest.ASPNetRequest">
            <summary>
            The ASP.NET request associated with this WCF request.
            </summary>
        </member>
        <member name="P:PerfView.WCFServerRequest.OverheadRequest">
            <summary>
            True iff this request is the WCF overhead request (used before a message is received).
            </summary>
        </member>
        <member name="P:PerfView.WCFServerRequest.NextRequestWithTheSameID">
            <summary>
            WCF makes the request ID the ID of the top most WCF request.  
            This works fine if there all calls from one WCF component to another
            are on different processes (e.g. machines).  However if not, then
            the same request ID might have more than one request associated with it
            We supprot this by making a linked list of these.  
            </summary>
        </member>
        <member name="M:PerfView.WCFServerRequest.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack index for the current request.
            </summary>
        </member>
        <member name="M:PerfView.WCFServerRequest.ToString">
            <summary>
            Serialize the request to a displayable string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:PerfView.WCFClientRequest">
            <summary>
            Represents a client-side WCF request.
            </summary>
        </member>
        <member name="P:PerfView.WCFClientRequest.ServiceAction">
            <summary>
            The service action.
            </summary>
        </member>
        <member name="P:PerfView.WCFClientRequest.ServerRequest">
            <summary>
            The parent server request.
            </summary>
        </member>
        <member name="M:PerfView.WCFClientRequest.ToString">
            <summary>
            Serialize this request to a displayable string.
            </summary>
            <returns></returns>
        </member>
        <member name="M:PerfView.WCFClientRequest.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.StackSourceCallStackIndex,Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread)">
            <summary>
            Get the call stack index for the current request.
            </summary>
        </member>
        <member name="T:PerfView.RequestKey">
            <summary>
            The composite key used to lookup a request.  The key is composed of the request id and the process id.
            </summary>
        </member>
        <member name="T:PerfView.ServerRequestThreadStateMap">
            <summary>
            A simple class that immplements lookup by Thread index and bulk clearning by request identity (Clear Request)
            
            It holds all state (ServerRequestThreadState) for all threads.  
            </summary>
        </member>
        <member name="T:PerfView.CallerCalleeView">
            <summary>
            Interaction logic for CallerCalleeView.xaml
            </summary>
            <summary>
            CallerCalleeView
            </summary>
        </member>
        <member name="M:PerfView.CallerCalleeView.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="P:PerfView.CallTreeView.Root">
            <summary>
            Returns the root node of the calltree being displayed
            </summary>
        </member>
        <member name="M:PerfView.CallTreeView.SetRoot(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode)">
            <summary>
            I did not make this a property because it is too profound an operation (heavy)
            This sets the root of the tree.  This is how you change the display to a new tree.  
            </summary>
        </member>
        <member name="M:PerfView.CallTreeView.Find(System.String)">
            <summary>
            Finds the .NET Regular expression 'pat' (case insensitive) in the call tree (does not matter if the node is visible or not).  
            Returns true if found.  
            </summary>
        </member>
        <member name="P:PerfView.CallTreeView.SelectedNode">
            <summary>
            Gets the first CallTreeViewNode for selected cells.   Returns null if there is no selected nodes. 
            </summary>
        </member>
        <member name="M:PerfView.CallTreeView.Select(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode)">
            <summary>
            Highlights (Selects) the given node.   This is how you navigate.  
            </summary>
        </member>
        <member name="P:PerfView.CallTreeView.DisplayPrimaryOnly">
            <summary>
            If this set only primary nodes are displayed.   
            </summary>
        </member>
        <member name="M:PerfView.CallTreeView.InsureVisible(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode)">
            <summary>
            Given a CallTreeNode, find a CallTreeViewNode for it (insuring that it is displayed
            </summary>
        </member>
        <member name="M:PerfView.CallTreeView.IndexInParent(Microsoft.Diagnostics.Tracing.Stacks.CallTreeNode)">
            <summary>
            Find the sampleIndex in the 'Callees' list of the parent for 'node'
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:PerfView.CallTreeViewNode">
            <summary>
            This is basically a CallTreeNode with extra state (state of expand boxes) associated needed for the viewer 
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.IsExpanded">
            <summary>
            Is the node expanded or not.  
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.Name">
            <summary>
            The TreeVieeNode uses the nodes DisplayName (which has a suffix string (surrounded by []) with extra information. 
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.IndentedName">
            <summary>
            This is IndentString followed by the display name.  
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.IndentString">
            <summary>
            Creates a string that has spaces | and + signs that represent the indentation level 
            for the tree node.  (Called from XAML)
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.HasChildren">
            <summary>
            Does this node have any children (invisible (unexpanded) children count))
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.IsSecondaryChild">
            <summary>
            A weak child is secondary
            </summary>
        </member>
        <member name="P:PerfView.CallTreeViewNode.VisibleChildren">
            <summary>
            Returns the list of code:CallTreeViewNode (rather than just code:CallTreeNode) associated
            with the children of this node (thus invible nodes are not present).   
            </summary>
        </member>
        <member name="M:PerfView.CallTreeViewNode.ExpandToDepth(System.Int32,System.Boolean)">
            <summary>
            Set 'IsExpanded of all nodes to a certain depth.  
            </summary>
            <param name="maxDepth">Maximum depth to expand</param>
            <param name="expandGraphNodes">If true graph nodes (which are not guarnteed to terminate) are expanded. </param>
        </member>
        <member name="P:PerfView.CallTreeViewNode.MyIndex">
            <summary>
            Returns the sampleIndex in the flattened tree (m_flattenedTree) of this tree node.  
            </summary>
        </member>
        <member name="M:PerfView.CallTreeViewNode.MakeChildren">
            <summary>
            An Unexpanded CallTreeViewNode does not have any children even if the Data (CallTreeNode) does
            This routine will make the necessary children (it is part of expanding the node).  
            </summary>
        </member>
        <member name="M:PerfView.CallTreeViewNode.CopyExpandedStateForNode(System.Collections.Generic.List{PerfView.CallTreeViewNode},System.Int32,PerfView.ObservableCollectionEx{PerfView.CallTreeViewNode},System.Int32)">
            <summary>
            It is assumed that the node oldFlattenedTree[oldIndex] and newFlattenedTree[newIndex] coorespond 
            to one another (have the same path to root) 
            Copies the expandedness of the node 'oldFlattenedTree[oldIndex]' to the new node at 
            newFlattenedTree[newIndex], as well as all the state for child node.  
            </summary>
        </member>
        <member name="M:PerfView.CallTreeViewNode.FindChild(PerfView.ObservableCollectionEx{PerfView.CallTreeViewNode},PerfView.CallTreeViewNode,System.Int32,System.String)">
            <summary>
            Given a node == flattenedTree[sampleIndex] find the sampleIndex in flattenedTree of a child with Data.NameBase == 'nameBame'
            </summary>
        </member>
        <member name="T:PerfView.ObservableCollectionEx`1">
            <summary>
            An observable colletion with the ability to insert a range of nodes without being super-inefficient.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:PerfView.PerfDataGrid">
            <summary>
            Interaction logic for PerfDataGrid.xaml
            </summary>
            <summary>
            PerfDataGrid
            </summary>
        </member>
        <member name="M:PerfView.PerfDataGrid.CompressContent(System.String)">
            <summary>
            Tries to make content smaller for cut and paste
            </summary>
        </member>
        <member name="M:PerfView.PerfDataGrid.PadForColumn(System.String,System.Int32)">
            <summary>
            given the content string, and the columnIndex, return a string that is propertly padded
            so that when displayed the rows will line up by columns nicely  
            </summary>
        </member>
        <member name="F:PerfView.PerfDataGrid.m_clipboardRangeStart">
            <summary>
            If we have only two cells selected, even if they are on differnet rows we want to morph them
            to a single row.  These variables are for detecting this situation.  
            </summary>
        </member>
        <member name="M:PerfView.PerfDataGrid.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.StackWindow">
            <summary>
            Interaction logic for StackWindow.xaml
            </summary>
            <summary>
            StackWindow
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.ChangeHeaderText(System.Windows.Controls.TabItem,System.String)">
            <summary>
            Changes the text of a header of 'tab' to 'newHeaderText' without losing the '?' hyperlinks.   
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.SetStackSource(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.Action)">
            <summary>
            This sets the window to to the given stack source, this DOES triggers an update of the gridViews.  
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.Update">
            <summary>
            Update causes the gridview's to be recalculated based on the current stack source filter parameters. 
            </summary>
        </member>
        <member name="P:PerfView.StackWindow.Filter">
            <summary>
            Note that setting the filter does NOT trigger an update of the gridViews.  You have to call Update()
            </summary>
        </member>
        <member name="P:PerfView.StackWindow.FilterGuiState">
            <summary>
            FilterGuiState is like 'Filter' in that it can set the filter paramters, but it goes further that it 
            can also set the history of each filter parameter (and other things that only the GUI cares about)
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.Find(System.String)">
            <summary>
            Find a pattern in the appropriate window.  The pattern is a .NET regular expression (case insensitive). 
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.FindByName(System.String)">
            <summary>
            Finds oin the ByName view.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:PerfView.StackWindow.FileName">
            <summary>
            If we save this view as a file, this is its name (may be null) 
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.PrimeWarmSymbols(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.Int32,PerfView.ETLPerfViewData,System.IO.TextWriter)">
            <summary>
            Given a source of stacks, a process ID, and and ETL file look up all the symbols for any module in
            that process that has more than 5% CPU time inclusive.   
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.ToCompactString(System.Single)">
            <summary>
            Creat a string that fits in 4 chars + a trailing space. 
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.SetFocusNodeToSelection">
            <summary>
            Sets the focus node to the currently selected cell, returns true if successful.  
            </summary>
            <returns></returns>
        </member>
        <member name="F:PerfView.StackWindow.ScalingPolicy">
            <summary>
            This is whether the sample being shown represent time and thus should be divided up or not.  
            </summary>
        </member>
        <member name="P:PerfView.StackWindow.ExtraTopStats">
            <summary>
            Intended to be called from ConfigureStackWindow
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.FindExeName(System.String)">
            <summary>
            This is and ugly routine that scrapes the data to find the full path (without the .exe extension) of the
            exe in the program.   It may fail (return nulls).   
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.StartsFullRow(System.Collections.Generic.IList{System.Windows.Controls.DataGridCellInfo},System.Int32,System.Int32)">
            <summary>
            Returns true if the cells starting at 'startIndex' begin a complete full row.  
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.SelectedCellStringValue">
            <summary>
            Returns the string value for a single selected cell.  Will return null on error 
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.UpdateDiffMenus(System.Collections.Generic.List{PerfView.StackWindow})">
            <summary>
            Insure that there is an entry for each element in 'stackWindows' in the diff menu. 
            </summary>
        </member>
        <member name="M:PerfView.StackWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:PerfView.ComputingResourceStateMachine">
             <summary>
             ComputingResourceStateMachine is the heart of a general framework for computing new views of computing resources
             based on the logical semantics of the program.    The basic idea is when program structure is async or parallel
             you want roll ups of costs (e.g. CPU, thread time, allocations), not by thread, but by some other logical entity
             (e.g. a request, or other 'causal chain').   Effectively this engine collates all the costs of a given logical
             entity (request) together so that you can understand them logically.  
             
             The basic idea is that semantically at any given point in time a thread might be doing work on behalf of some
             logical entity (like a request).   Each thread is effectively a 'contractor' that can 'charge' its work to 
             any of the logical entities.  Thus the ComputingResourceStateMachine keeps track of the 'charge back state' 
             of each thread, and keeps them straight.
             
             Now ComputingResourceStateMachine wishes to NOT understand the details of how to determine who to charge.  
             This is the job of the ScenarioConfiguration class.   This frees up ComputingResourceStateMachine to just
             worry about those things that are independent of particular charge back schemes.  This includes
            
                 1) Understanding the basics of thread tracking (threads starts and stops ...)
                 2) Keeping track of the resources themselves (CPU, Allocation, Thread Time)
                 3) In the case of Thread Time, keeping track of the state machine for calculating it from CSWITCH data.  
                 4) It also acts as a repository for the stackSource being created.   
             </summary>
        </member>
        <member name="M:PerfView.ComputingResourceStateMachine.Execute">
            <summary>
            Run the state machine to produce the stackSource given in the constructor.  
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceStateMachine.Configuration">
            <summary>
            Get the scenario configuration.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceStateMachine.StackSource">
            <summary>
            The stackSource being generated.   
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceStateMachine.Sample">
            <summary>
            For efficiency, we reuse the same sample to place items in the stacksource.  This is that reused sample.  
            </summary>
        </member>
        <member name="F:PerfView.ComputingResourceStateMachine.m_Sample">
            <summary>
            As an optimization we reuse the same sample when adding samples to the m_StackSource, this is that sample 
            </summary>
        </member>
        <member name="F:PerfView.ComputingResourceStateMachine.m_ThreadState">
            <summary>
            The thread state required for profiling computing resources.
            </summary>
        </member>
        <member name="T:PerfView.ScenarioConfiguration">
            <summary>
            Connects the two state machines together.
            </summary>
            <remarks>
            Responsible for creation of the scenario state machine and scenario thread state.
            Tells the computing resource state machine about the scenario state machine.
            Tells the computing resource about the custom data that must be stored in the thread state.
            Stores and manages the scenario thread state for every thread in the trace.
                 (A given scenario thread state needs unfettered access to scenario thread state on other threads to e.g. clear a request off another thread.)
            </remarks>
        </member>
        <member name="P:PerfView.ScenarioConfiguration.TraceLog">
            <summary>
            The trace log to be consumed.
            </summary>
        </member>
        <member name="P:PerfView.ScenarioConfiguration.ScenarioStateMachine">
            <summary>
            Get the scenario state machine.
            </summary>
            <remarks>
            This member is responsible for storage of the state machine, and must not create a new one on each call.
            </remarks>
        </member>
        <member name="P:PerfView.ScenarioConfiguration.ScenarioThreadState">
            <summary>
            Get the thread state associated with the scenario.
            </summary>
            <remarks>
            This class is responsible for initialization of the thread state, based on input to the constructor (e.g. the trace log is required to know how many threads exist).
            Index into this array by using the ThreadIndex.
            </remarks>
        </member>
        <member name="F:PerfView.ScenarioConfiguration.StackChanged">
            <summary>
            Fired if any changes in the stack occur during blocked times
            </summary>
        </member>
        <member name="T:PerfView.ScenarioStateMachine">
            <summary>
            The state machine that represents the actual scenario.
            </summary>
            <remarks>
            Understands the scenario that the data is used for.
            Knows how to slice the data to make it useful (e.g. into requests).
            Determines whether samples should be attributed or thrown out (?)
            </remarks>
        </member>
        <member name="P:PerfView.ScenarioStateMachine.Configuration">
            <summary>
            Get the configuration associated with the state machine.
            </summary>
            <remarks>
            For performance reasons, it is recommended that state machines keep a reference to the scenario thread state, so that it does not need to be casted to the actual type multiple times.
            </remarks>
        </member>
        <member name="M:PerfView.ScenarioStateMachine.RegisterEventHandlers(Microsoft.Diagnostics.Tracing.TraceEventDispatcher)">
            <summary>
            Register event handlers before data is processed.
            </summary>
        </member>
        <member name="T:PerfView.ScenarioThreadState">
            <summary>
            Contains the thread state associated with the scenario.
            </summary>
        </member>
        <member name="M:PerfView.ScenarioThreadState.GetCallStackIndex(Microsoft.Diagnostics.Tracing.Stacks.MutableTraceEventStackSource,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
             <summary>
             Get the 'logcal' call stack from PROCESS ROOT (the root of all stacks) to (but not including) the frame for the
             thread.   By default (if you can't attribute it to anything else) it will just be attributed to the process, however
             it is likley that you want to insert pseudo-frames for the request and other logical groupings here.  
             
             The actual method frames within a thread, as well as any resource specific pseduo-frames (e.g. BLOCKING, ...)
             are added by the ComputingResourceMachine itself.  
            </summary>   
        </member>
        <member name="T:PerfView.ComputingResourceViewType">
            <summary>
            The types of resources ComputingResourceStateMachine understands how to gather.  
            </summary>
        </member>
        <member name="T:PerfView.ComputingResourceThreadState">
            <summary>
            ComputingResourceThreadState contains the state of the thread that ComputingResourceStateMachine needs to do its work.   
            
            It is only used by ComputingResourceStateMachine and it basically keeps track of the thread state (blocked, running etc)
            of each thread.   
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.ThreadIndex">
            <summary>
            The thread index associated with this thread.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.BlockTimeStartRelativeMSec">
            <summary>
            The start time associated with a blocked thread.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.ThreadDead">
            <summary>
            True iff the thread is dead.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.ThreadRunning">
            <summary>
            True iff the threadd isrunning.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.ThreadBlocked">
            <summary>
            True iff the thread is blocked.
            </summary>
        </member>
        <member name="P:PerfView.ComputingResourceThreadState.ThreadUninitialized">
            <summary>
            True iff the thread is unitialized.
            </summary>
        </member>
        <member name="M:PerfView.ComputingResourceThreadState.LogBlockingStart(PerfView.ComputingResourceStateMachine,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Mark the thread as blocked.
            </summary>
        </member>
        <member name="M:PerfView.ComputingResourceThreadState.LogBlockingStop(PerfView.ComputingResourceStateMachine,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Mark the thread as unblocked.
            </summary>
        </member>
        <member name="M:PerfView.ComputingResourceThreadState.LogCPUSample(PerfView.ComputingResourceStateMachine,Microsoft.Diagnostics.Tracing.Etlx.TraceThread,Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Log a CPU sample on this thread.
            </summary>
        </member>
        <member name="T:PerfView.Utilities.FastStream">
            <summary>
            The is really what BinaryReader should have been... (sigh)
            
            We need really fast, byte-by-byte streaming. ReadChar needs to be inliable .... All the routines that
            give back characters assume the bytes are ASCII (The translations from bytes to chars is simply a
            cast).
            
            The basic model is that of a Enumerator. There is a 'Current' property that represents the current
            byte, and 'MoveNext' that moves to the next byte and returns false if there are no more bytes. Like
            Enumerators 'MoveNext' needs to be called at least once before 'Current' is valid.
            
            Unlike standard Enumerators, FastStream does NOT consider it an error to read 'Current' is read when
            there are no more characters.  Instead Current returns a Sentinal value (by default this is 0, but
            the 'Sentinal' property allow you to choose it).   This is often more convenient and efficient to
            allow checking end-of-file (which is rare), to happen only at certain points in the parsing logic.  
            
            Another really useful feature of this stream is that you can peek ahead efficiently a large number
            of bytes (since you read ahead into a buffer anyway).
            </summary>
        </member>
        <member name="F:PerfView.Utilities.FastStream.Sentinal">
            <summary>
            For efficient reads, we allow you to read Current past the end of the stream.  You will
            get the 'Sentinal' value in that case.  This defaults to 0, but you can change it if 
            there is a better 'rare' value to use as an end of stream marker.  
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.ReadAsciiStringUpToAny(System.String,System.Text.StringBuilder)">
            <summary>
            Reads the string into the stringBuilder until a byte is read that
            is one of the characters in 'endMarkers'.  
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.ReadAsciiStringUpToLastBeforeTrue(System.Char,System.Text.StringBuilder,System.Func{System.Byte,System.Boolean})">
            <summary>
            Reads the stream into the string builder until the last end marker on the line is hit.
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.ReadAsciiStringUpToTrue(System.Text.StringBuilder,System.Func{System.Byte,System.Boolean})">
            <summary>
            Reads the stream in the string builder until the given predicate function is false.
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.Peek(System.UInt32)">
            <summary>
            Returns a number of bytes ahead without advancing the pointer. 
            Peek(0) is the same as calling Current.  
            </summary>
            <param name="bytesAhead"></param>
            <returns></returns>
        </member>
        <member name="M:PerfView.Utilities.FastStream.Skip(System.UInt32)">
            <summary>
            Moves through the FastStream without actually reading data.
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.ReadSubStream(System.Int32,System.String)">
            <summary>
            Creates a FastStream with the read in stream with the given length.
            The "trail" is am ASCII string that is attached to the end of the returned FastStream.
            </summary>
        </member>
        <member name="M:PerfView.Utilities.FastStream.PeekString(System.Int32)">
            <summary>
            Gets a string from the position to the length indicated (for debugging)
            </summary>
        </member>
        <member name="T:PerfView.ProcessInfo">
            <summary>
            A code:ProcessInfo represents a process that existed at the time a snapshot was taken with
            the code:ProcessInfo constructor.  It basically is a set of read-only properties describing
            the process.   
            </summary>
        </member>
        <member name="M:PerfView.ProcessInfo.TimeStr(System.TimeSpan)">
            <summary>
            Returns a time span picking good units so that it can be expressed in a small amount of
            space (5 spaces)
            </summary>
            <param name="span"></param>
            <returns></returns>
        </member>
        <member name="M:PerfView.ProcessInfo.CompressCommandLine(System.String,System.Int32)">
            <summary>
            Given a command line, compress out uninteresting parts to show the most important part. 
            </summary>
        </member>
        <member name="T:PerfView.ProcessInfos">
            <summary>
            code:ProcessInfos represents the collection of all processes on the machine.   When you create a
            ProcessInfos object, a snapshot of process information is taken, which can then be traversed.  
            </summary>
        </member>
        <member name="M:PerfView.ProcessInfos.#ctor">
            <summary>
            Create a new snapshot of the processes on the machine.  
            </summary>
        </member>
        <member name="P:PerfView.ProcessInfos.Processes">
            <summary>
            Used to enumerate all the processes that existed at the time the snapshot was taken
            </summary>
        </member>
        <member name="P:PerfView.ProcessInfos.Item(System.Int32)">
            <summary>
            Look up a particular process by process ID.  If it does not exist, null is returned. 
            </summary>
        </member>
        <member name="P:PerfView.ProcessInfos.Orphans">
            <summary>
            Return the collection of all processes that do not have a parent.  This is the natural
            starting point for traversing the processes organized by which process spawned which.
            </summary>
        </member>
        <member name="M:PerfView.ProcessInfos.ToString">
            <summary>
            Returns a 
            </summary>
            <returns></returns>
        </member>
        <member name="T:PerfView.UsersGuide">
            <summary>
            Privides a quick HTML users guide.  
            </summary>
        </member>
        <member name="M:PerfView.UsersGuide.DisplayUsersGuide(System.String,System.String)">
            <summary>
            Displayes an the embeded HTML user's guide in a browser. 
            </summary>
            <returns>true if successful.</returns>
        </member>
        <member name="T:PerfView.App">
             <summary>
             The App Class is the main program
            
             We don't do the normal WPF style main (where WPF is responsible for the main program because 
             on ARM devices we don't have WPF, however we still want to enable some things (like data collection).   
             Thus we need to defer touching WPF until we know we need it.  To do this we take explicit control over
             the Entry point and do command line processing first, before doing any GUI stuff.  
             </summary>
        </member>
        <member name="M:PerfView.App.Main(System.String[])">
            <summary>
            At the top most level, Main simply calls 'DoMain' insuring that all error messages get to the user.  
            Main is also responsible for doing the 'install On First launch' logic that unpacks the EXE if needed.  
            </summary>  
        </member>
        <member name="M:PerfView.App.DoMain(System.String[],System.Boolean@,System.IO.StreamWriter@)">
            <summary>
            DoMain's job is to parse the args, and determine if we should be using the GUI or the command line, then execute
            the command in the appropriate environment.  
            </summary>
            <param name="args">The arguments to the program</param>
            <param name="newConsoleCreated">If we created a new console window (and thus we should wait before closing it on exit, set this)</param>
            <param name="textWriterToCleanUp">If you create a StreamWriter, set this so we clean it up on exit.</param>
            <returns></returns>
        </member>
        <member name="M:PerfView.App.DoMainForGui">
            <summary>
            Logic in DoMainForGui was segregated into its own method so that we don't load WPF until we need to (for ARM)
            </summary>
        </member>
        <member name="P:PerfView.App.LogFileName">
            <summary>
            Returns the name of the log file that is saved for any perfView instance.   It is the /LogFile parameter if given,
            otherwise it is a generate name in the Temp\PerfView directory.   
            </summary>
        </member>
        <member name="M:PerfView.App.Unpack">
            <summary>
            Unpacks all the support files associated with this program.   
            </summary>
        </member>
        <member name="M:PerfView.App.SetPermissionsForWin8Apps">
            <summary>
            This code is separated into its own method because it uses Command, which is in TraceEvent.dll, which was
            unpacked in the  previous step.   
            </summary>
        </member>
        <member name="M:PerfView.App.RelaunchIfNeeded(System.String[])">
            <summary>
            This code is only needed because we let people run PerfView.exe from a network file 
            share and we want to update the file share easily.  Currently windows makes this
            problematic (you can't update without forcibly closing the file).  Our solution is 
            to copy the EXE locally and run it there, so there is only a very short time where
            perfView is actually being run from the network.  
            
            TODO this can be removed when we don't update PerfView commonly and are willing 
            to 'kick people off' when we need to do an update.  
            </summary>
        </member>
        <member name="P:PerfView.App.IsElevated">
            <summary>
            True if the process is elevated. 
            </summary>
        </member>
        <member name="M:PerfView.App.GetSymbolReader(System.String,Microsoft.Diagnostics.Symbols.SymbolReaderOptions)">
            <summary>
            A SymbolReader contains all the context (symbol path, symbol lookup preferences ...) needed
            to look up PDB files needed to give events in the TraceLog symbolic names.  Note that by 
            default this symbol path includes directories relative to the TraceLog (the directory and 
            a 'Symbols' directory next to the file).  
            </summary>
        </member>
        <member name="M:PerfView.App.MakeUniversalIfPossible(System.String)">
            <summary>
            Convert a network drive (e.g. Z:\testing) to its universal name (e.g. \\clrmain\public\testing).   
            </summary>
        </member>
        <member name="F:PerfView.App.ConsoleCreated">
            <summary>
            Tries to fetch the console that created this process or creates a new one if the parent process has no 
            console.   Returns true if a NEW console has been created.  
            </summary>
        </member>
        <member name="T:PerfView.AppLog">
            <summary>
            APIs for logging usage data and feedback.
            </summary>
        </member>
        <member name="P:PerfView.AppLog.CanSendFeedback">
            <summary>
            Returns true if you have access to the file share where we log feedback
            </summary>
        </member>
        <member name="P:PerfView.AppLog.InternalUser">
            <summary>
            Are we internal to Microsoft (and thus can have experimental features. 
            </summary>
        </member>
        <member name="M:PerfView.AppLog.LogUsage(System.String,System.String,System.String)">
            <summary>
            Log that the event 'eventName' with an optional string arg happened.  Will
            get stamped with the time, user, and session ID.  
            </summary>
        </member>
        <member name="M:PerfView.AppLog.SendFeedback(System.String,System.Boolean)">
            <summary>
            Called if you wish to send feedback to the developer.  Returns true if successful
            We segregate feedback into crashes and suggestions.  
            </summary>
        </member>
        <member name="T:PerfView.VerboseLogWriter">
            <summary>
            VerboseLogWriter is a textWriter that forwards everything to 'verboseLog' but
            also sends any lines in [] to the 'terseLog'. 
            </summary>
        </member>
        <member name="T:PerfView.GuiApp">
            <summary>
            Interaction logic for App.xaml
            </summary>
        </member>
        <member name="F:PerfView.GuiApp.MainWindow">
            <summary>
            The one and only main GUI window of the application.  
            </summary>
        </member>
        <member name="M:PerfView.GuiApp.ApplicationStarted">
            <summary>
            Called when the application is started.  
            </summary>
        </member>
        <member name="M:PerfView.GuiApp.OnGuiUnhandledException(System.Object,System.Windows.Threading.DispatcherUnhandledExceptionEventArgs)">
            <summary>
            Called when exception happens in a GUI routine 
            </summary>
        </member>
        <member name="M:PerfView.GuiApp.OnUnhandledException(System.Object,System.UnhandledExceptionEventArgs)">
            <summary>
            Fallback if we happen to take an exception in a non-gui routine (shouldn't happen!) 
            </summary>
        </member>
        <member name="T:PerfView.MainWindow">
            <summary>
            The main window of the performance viewer. 
            </summary>
            <summary>
            MainWindow
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.OpenPath(System.String,System.Boolean)">
            <summary>
            Set the left pane to the specified directory.  If it is a file name, then that file name is opened
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.Open(System.String,PerfView.PerfViewFile,System.Action)">
            <summary>
            Given a file name and format open the file (if format is null we try to infer the format from the file extension)
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.OpenStacks(System.String,PerfView.PerfViewFile,System.String)">
            <summary>
            Opens a stack source of a given name (null is the default) for a given file.
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.TakeHeapShapshot(System.Action)">
            <summary>
            Open the Memory Dump dialog.  If processDumpFile == null then it will prompt for a live process.
            It will prime the process dump file from the given string.  
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.HideWindow">
            <summary>
            Hides the window (if it can still be reached).  
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.ExecuteCommand(System.String,System.Action{PerfView.CommandLineArgs},PerfView.StatusBar,System.Action,System.Action)">
            <summary>
            This is a helper that performs a command line style action, logging output to the log.  
            statusMessage is what is displayed while the command is executing.  
            
            If continuation is non-null it is executed after the command completes successfully 
            If _finally is non-null, it is executed after the command (and continuation), even if the command is unsuccessful.  
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.DoSetSymbolPath(System.Object,System.Windows.RoutedEventArgs)">
            GUI command callbacks
        </member>
        <member name="M:PerfView.MainWindow.RefreshCurrentDirectory">
            <summary>
            Refreshes the current shown directory
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.ChangeCurrentDirectoryIfNeeded">
            <summary>
            If we can't write to the directory as a normal user, change the directory to your home directory.  
            This is useful if PerfVIew is launch from embeded E-mail to avoid writing in \Program Files
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.OpenNext(System.String)">
            <summary>
            Indicates that 'outputFileName' should be opened after the command is completed.  
            </summary>
        </member>
        <member name="M:PerfView.MainWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="M:PerfView.StreamUtilities.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            CopyStream simply copies 'fromStream' to 'toStream'
            </summary>
        </member>
        <member name="T:PerfView.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:PerfView.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:PerfView.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:GCHeapDump">
            <summary>
            Represents a .GCDump file.  You can open it for reading with the construtor
            and you can write one with WriteMemoryGraph 
            </summary>
        </member>
        <member name="M:GCHeapDump.WriteMemoryGraph(Graphs.MemoryGraph,System.String,System.String)">
            <summary>
            Writes the memory graph 'graph' as a .gcump file to 'outputFileName'
            'toolName' is the name of the tool generating the data.  It is persisted in the GCDump file
            and can be used by the viewer to customize the view.  
            
            TODO can't set the rest of the meta-data associated with the graph this way.  
            </summary>
        </member>
        <member name="P:GCHeapDump.MemoryGraph">
            <summary>
            The 
            </summary>
        </member>
        <member name="P:GCHeapDump.InteropInfo">
            <summary>
            Information about COM objects that is not contained in the MemoryGraph.  
            </summary>
        </member>
        <member name="P:GCHeapDump.Is64Bit">
            <summary>
            TODO FIX NOW REMOVE DO NOT USE  Use MemoryGraph.Is64Bit instead.    
            Was this dump taken from a 64 bit process
            </summary>
        </member>
        <member name="P:GCHeapDump.AverageCountMultiplier">
            <summary>
            If we have sampled, sampleCount * ThisMultiplier = originalCount.   If sampling not done then == 1
            </summary>
        </member>
        <member name="P:GCHeapDump.AverageSizeMultiplier">
            <summary>
            If we have sampled sampledSize * thisMultiplier = originalSize.  If sampling not done then == 1
            </summary>
        </member>
        <member name="P:GCHeapDump.CountMultipliersByType">
            <summary>
            This can be null.  If non-null it indicates that only a sample of the GC graph was persisted in 
            the MemoryGraph filed.  To get an approximation of the original heap, each type's count should be 
            scaled CountMultipliersByType[T] to get the unsampled count of the original heap.
            
            We can't use a uniform number for all types because we want to see all large objects, and we 
            want to include paths to root for all objects, which means we can only approximate a uniform scaling.  
            </summary>
        </member>
        <member name="P:GCHeapDump.CollectionLog">
            <summary>
            This is the log file that was generated at the time of collection 
            </summary>
        </member>
        <member name="P:GCHeapDump.CreationTool">
            <summary>
            Returns a string that represents the tool that created this GCDump file.  May be null if not known/supported.  
            </summary>
        </member>
        <member name="M:GCHeapDump.GetProcessesWithGCHeaps">
            <summary>
            returns a list of ProcessInfos that indicate which processes
            have use a runtime .NET or JavaScript that we can potentially dump
            
            Note that for 64 bit systems this will ONLY return processes that
            have the same bitness as the current process (for PerfView it is 32 bit)
            </summary>
        </member>
        <member name="M:GCHeapDump.Write(System.String)">
            <summary>
            Writes the data to 'outputFileName'   
            </summary>
        </member>
        <member name="M:GCHeapDump.PreVersion8FromStream(FastSerialization.Deserializer)">
            <summary>
            Deals with legacy formats.  We should be able to get rid of eventually.  
            </summary>
        </member>
        <member name="T:XmlGcHeapDump">
            <summary>
            Reads the format as an XML file.   It it is a very simple format  Here is an example. 
            <graph>
              <rootIndex>3</rootIndex>
              <nodeTypes>
                <nodeType Index="1" Size="10" Name="Type1" Module="MyModule" />
                <nodeType Index="2" Size="1" Name="Type2" />
                <nodeType Index="3" Size="20" Name="Type3" />
                <nodeType Index="4" Size="10" Name="Type4" Module="MyModule" />
              </nodeTypes>
              <nodes>
                <node Index="1" Size="100" TypeIndex="1" >2</node>
                <node Index="2" TypeIndex="1" >3</node>
                <node Index="3" TypeIndex="1" >1 4</node>
                <node Index="4" TypeIndex="4" >2</node>
              </nodes>
            </graph>
            
            </summary>
        </member>
        <member name="M:XmlGcHeapDump.ReadNodeTypesFromXml(System.Xml.XmlReader,Graphs.MemoryGraph)">
            <summary>
            Reads the NodeTypes element
            </summary>
        </member>
        <member name="M:XmlGcHeapDump.ReadNodesFromXml(System.Xml.XmlReader,Graphs.MemoryGraph)">
            <summary>
            Reads the Nodes Element
            </summary>
        </member>
        <member name="M:XmlGcHeapDump.FetchInt(System.Xml.XmlReader,System.String,System.Int32)">
            <summary>
            Reads an given attribute as a integer
            </summary>
        </member>
        <member name="T:Graphs.Graph">
             <summary>
             A graph is representation of a node-arc graph.    It tries to be very space efficient.   It is a little
             more complex than the  most basic node-arc graph in that each node can have a code:NodeType associated with it 
             that contains information that is shared among many nodes.   
             
             While the 'obvious' way of representing a graph is to have a 'Node' object that has arcs, we don't do this. 
             Instead each node is give an unique code:NodeIndex which represents the node and each node has a list of
             NodeIndexes for each of the children.   Using indexes instead of object pointers is valuable because
             
                 * You can save 8 bytes (on 32 bit) of .NET object overhead and corresponding cost at GC time by using
                   indexes.   This is significant because there can be 10Meg of objects, so any expense adds up
                 * Making the nodes be identified by index is more serialization friendly.   It is easier to serialize
                   the graph if it has this representation.  
                 * It easily allows 3rd parties to 'attach' their own information to each node.  All they need is to
                   create an array of the extra information indexed by NodeIndex.   The 'NodeIndexLimit' is designed
                   specifically for this purpose.  
                   
             Because we anticipate VERY large graphs (e.g. dumps of the GC heap) the representation for the nodes is 
             very space efficient and we don't have code:Node class object for most of the nodes in the graph.  However
             it IS useful to have code:Node objects for the nodes that are being manipulated locally.  
            
             To avoid creating lots of code:Node objects that die quickly the API adopts the convention that the
             CALLer provides a code:Node class as 'storage' when the API needs to return a code:Node.   That way
             APIs that return code:Node never allocate.    This allows most graph algorithms to work without having
             to allocate more than a handful of code:Node classes, reducing overhead.   You allocate these storage
             nodes with the code:Graph.AllocNodeStorage call
             
             Thus the basic flow is you call code:Graph.AllocNodeStorage to allocate storage, then call code:Graph.GetRoot
             to get your first node.  If you need to 'hang' additional information off he nodes, you allocate an array
             of Size code:Graph.NodeIndexLimit to hold it (for example a 'visited' bit).   Then repeatedly call 
             code:Node.GetFirstChild, code:Node.GetNextChild to get the children of a node to traverse the graph.
             
             OVERHEAD
            
                 1) 4 bytes per Node for the pointer to the stream for the rest of the data (thus we can have at most 4Gig nodes)
                 2) For each node, the number of children, the nodeId, and children are stored as compressed (relative) indexes 
                    (figure 1 byte for # of children, 2 bytes per type id, 2-3 bytes per child)
                 3) Variable length nodes also need a compressed int for the Size of the node (1-3 bytes)
                 4) Types store the name (2 bytes per character), and Size (4 bytes), but typically don't dominate 
                    Size of graph.  
            
             Thus roughly 7 bytes per node + 3 bytes per reference.   Typically nodes on average have 2-3 references, so
             figure 13-16 bytes per node.  That gives you 125 Million nodes in a 2 Gig of Memory. 
             
             The important point here is that representation of a node is always smaller than the Memory it represents, and
             and often significantly smaller (since it does not hold non-GC data, null pointers and even non-null pointers 
             are typically half the Size).   For 64 bit heaps, the Size reduction is even more dramatic.  
             
             see code:Graph.SizeOfGraphDescription to determine the overhead for any particular graph.
             
             </summary>
        </member>
        <member name="M:Graphs.Graph.GetNode(Graphs.NodeIndex,Graphs.Node)">
            <summary>
            Given an arbitrary code:NodeIndex that identifies the node, Get a code:Node object.  
            
            This routine does not allocated but uses the space passed in by 'storage.  
            'storage' should be allocated with coode:AllocNodeStorage, and should be agressively reused.  
            </summary>
        </member>
        <member name="M:Graphs.Graph.IsDefined(Graphs.NodeIndex)">
            <summary>
            returns true if SetNode has been called on this node (it is not an undefined object).  
            TODO FIX NOW used this instead of the weird if node index grows technique. 
            </summary>
        </member>
        <member name="M:Graphs.Graph.GetType(Graphs.NodeTypeIndex,Graphs.NodeType)">
            <summary>
            Given an arbitrary code:NodeTypeIndex that identifies the nodeId of the node, Get a code:NodeType object.  
            
            This routine does not allocated but overwrites the space passed in by 'storage'.  
            'storage' should be allocated with coode:AllocNodeTypeStorage, and should be agressively reused.  
            
            Note that this routine does not get used much, instead Node.GetType is normal way of getting the nodeId.  
            </summary>
        </member>
        <member name="M:Graphs.Graph.AllocNodeStorage">
            <summary>
            Allocates nodes to be used as storage for methods like code:GetRoot, code:Node.GetFirstChild and code:Node.GetNextChild
            </summary>
            <returns></returns>
        </member>
        <member name="M:Graphs.Graph.AllocTypeNodeStorage">
            <summary>
            Allocates nodes to be used as storage for methods like code:GetType
            </summary>
        </member>
        <member name="P:Graphs.Graph.NodeIndexLimit">
            <summary>
            It is expected that users will want additional information associated with nodes of the graph.  They can
            do this by allocating an array of code:NodeIndexLimit and then indexing this by code:NodeIndex
            </summary>
        </member>
        <member name="P:Graphs.Graph.NodeCount">
            <summary>
            Same as NodeIndexLimit, just cast to an integer.  
            </summary>
        </member>
        <member name="P:Graphs.Graph.NodeTypeIndexLimit">
            <summary>
            It is expected that users will want additional information associated with TYPES of the nodes of the graph.  They can
            do this by allocating an array of code:NodeTypeIndexLimit and then indexing this by code:NodeTypeIndex
            </summary>
        </member>
        <member name="P:Graphs.Graph.NodeTypeCount">
            <summary>
            Same as NodeTypeIndex cast as an integer.  
            </summary>
        </member>
        <member name="P:Graphs.Graph.TotalSize">
            <summary>
            When a Node is created, you specify how big it is.  This the sum of all those sizes.  
            </summary>
        </member>
        <member name="P:Graphs.Graph.TotalNumberOfReferences">
            <summary>
            The number of references (arcs) in the graph
            </summary>
        </member>
        <member name="M:Graphs.Graph.#ctor(System.Int32)">
            <summary>
            Create a new graph from 'nothing'.  Note you are not allowed to read from the graph
            until you execute 'AllowReading'.  
            
            You can actually continue to write after executing 'AllowReading' however you should
            any additional nodes you write should not be accessed until you execute 'AllowReading'
            again.  
            
            TODO I can eliminate the need for AllowReading.  
            </summary>
        </member>
        <member name="F:Graphs.Graph.RootIndex">
            <summary>
            The NodeIndex of the root node of the graph.   It must be set sometime before calling AllowReading
            </summary>
        </member>
        <member name="M:Graphs.Graph.CreateType(System.String,System.String,System.Int32)">
            <summary>
            Create a new nodeId with the given name and return its node nodeId index.   No interning is done (thus you can
            have two distinct NodeTypeIndexes that have exactly the same name.  
            
            By default the size = -1 which indicates we will set the type size to the first 'SetNode' for this type.  
            </summary>
        </member>
        <member name="M:Graphs.Graph.CreateNode">
            <summary>
            Create a new node and return its index.   It is undefined until code:SetNode is called.   We allow undefined nodes
            because graphs have loops in them, and thus you need to refer to a node, before you know all the data in the node.
            
            It is really expected that every node you did code:CreateNode on you also ultimately do a code:SetNode on.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Graphs.Graph.SetNode(Graphs.NodeIndex,Graphs.NodeTypeIndex,System.Int32,System.Collections.Generic.GrowableArray{Graphs.NodeIndex})">
            <summary>
            Sets the information associated with the node at 'nodeIndex' (which was created via code:CreateNode).  Nodes
            have a nodeId, Size and children.  (TODO: should Size be here?)
            </summary>
        </member>
        <member name="M:Graphs.Graph.AllowReading">
            <summary>
            When a graph is construted with the default constructor, it is in 'write Mode'  You can't read from it until 
            you call 'AllowReading' which puts it in 'read mode'.  
            </summary>
        </member>
        <member name="M:Graphs.Graph.ToString">
            <summary>
            Used for debugging, returns the node Count and typeNode Count. 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Graphs.Graph.SizeOfGraphDescription">
            <summary>
            A pretty good estimate of the how many bytes of Memory it takes just to represent the graph itself. 
            
            TODO: Currently this is only correct for the 32 bit version.  
            </summary>
        </member>
        <member name="M:Graphs.Graph.CreateType(System.Int32,Graphs.Module,System.Int32,System.String)">
            <summary>
            Graph supports the ability to look up the names of a type at a later time.   You use this by 
            calling this overload in which you give a type ID (e.g. an RVA) and a module index (from 
            CreateModule) to this API.   If later you override the 'ResolveTypeName' delegate below
            then when type names are requested you will get back the typeID and module which you an
            then use to look up the name (when you do have the PDB). 
            
            The Module passed should be reused as much as possible to avoid bloated files.  
            </summary>
        </member>
        <member name="P:Graphs.Graph.ResolveTypeName">
            <summary>
            In advanced scenarios you may not be able to provide a type name when you create the type.  YOu can pass null
            for the type name to 'CreateType'   If you provide this callback, later you can provide the mapping from 
            type index to name (e.g. when PDBs are available).    Note that this field is NOT serialized.   
            </summary>
        </member>
        <member name="P:Graphs.Graph.HasDeferedTypeNames">
            <summary>
            Where any types in the graph creates with the CreateType(int typeID, Module module, int size) overload?
            </summary>
        </member>
        <member name="M:Graphs.Graph.Clear">
            <summary>
            Clear handles puts it back into the state that existed after the constructor returned
            </summary>
        </member>
        <member name="M:Graphs.Graph.ClearWorker">
            <summary>
            ClearWorker does only that part of clear needed for this level of the hierarchy (and needs
            to be done by the constructor too). 
            </summary>
        </member>
        <member name="T:Graphs.Node">
            <summary>
            Node represents a single node in the code:Graph.  These are created lazily and follow a pattern were the 
            CALLER provides the storage for any code:Node or code:NodeType value that are returned.   Thus the caller
            is responsible for determine when nodes can be reused to minimuze GC cost.  
            
            A node implicitly knows where the 'next' child is (that is it is an iterator).  
            </summary>
        </member>
        <member name="M:Graphs.Node.ResetChildrenEnumeration">
            <summary>
            Reset the internal state so that 'GetNextChildIndex; will return the first child.  
            </summary>
        </member>
        <member name="M:Graphs.Node.GetFirstChildIndex">
            <summary>
            Gets the index of the first child of node.  Will return NodeIndex.Invalid if there are no children. 
            </summary>
            <returns>The index of the child </returns>
        </member>
        <member name="P:Graphs.Node.ChildCount">
            <summary>
            Returns the number of children this node has.  
            </summary>
        </member>
        <member name="M:Graphs.Node.Contains(Graphs.NodeIndex)">
            <summary>
            Returns true if 'node' is a child of 'this'.  childStorage is simply used as temp space 
            as was allocated by Graph.AllocateNodeStorage
            </summary>
        </member>
        <member name="T:Graphs.NodeType">
            <summary>
            Represents the nodeId of a particular node in the graph.  
            </summary>
        </member>
        <member name="P:Graphs.NodeType.Name">
            <summary>
            Every nodeId has a name, this is it.  
            </summary>
        </member>
        <member name="P:Graphs.NodeType.FullName">
            <summary>
            This is the ModuleName ! Name (or just Name if ModuleName does not exist)  
            </summary>
        </member>
        <member name="P:Graphs.NodeType.Size">
            <summary>
            Size is defined as the Size of the first node in the graph of a given nodeId.   
            For types that always have the same Size this is useful, but for types (like arrays or strings)
            that have variable Size, it is not useful.  
            
            TODO keep track if the nodeId is of variable Size
            </summary>
        </member>
        <member name="P:Graphs.NodeType.ModuleName">
            <summary>
            The module associated with the type.  Can be null.  Typically this is the full path name.  
            </summary>
        </member>
        <member name="T:Graphs.Module">
            <summary>
            Holds all interesting data about a module (in particular enough to look up PDB information)
            </summary>
        </member>
        <member name="M:Graphs.Module.#ctor(System.UInt64)">
            <summary>
            Create new module.  You must have at least a image base.   Everything else is optional.
            </summary>
        </member>
        <member name="F:Graphs.Module.Path">
            <summary>
            The path to the Module (can be null if not known)
            </summary>
        </member>
        <member name="F:Graphs.Module.ImageBase">
            <summary>
            The location where the image was loaded into memory
            </summary>
        </member>
        <member name="F:Graphs.Module.Size">
            <summary>
            The size of the image when loaded in memory
            </summary>
        </member>
        <member name="F:Graphs.Module.BuildTime">
            <summary>
            The time when this image was built (There is a field in the PE header).   May be MinimumValue if unknonwn. 
            </summary>
        </member>
        <member name="F:Graphs.Module.PdbName">
            <summary>
            The name of hte PDB file assoicated with this module.   Ma bye null if unknown
            </summary>
        </member>
        <member name="F:Graphs.Module.PdbGuid">
            <summary>
            The GUID that uniquely identfies this PDB for symbol server lookup.  May be Guid.Empty it not known.  
            </summary>
        </member>
        <member name="F:Graphs.Module.PdbAge">
            <summary>
            The age (version number) that is used for symbol server lookup.  
            </summary>T
        </member>
        <member name="M:Graphs.Module.ToStream(FastSerialization.Serializer)">
            <summary>
            Implementing IFastSerializable interface.  
            </summary>
        </member>
        <member name="M:Graphs.Module.FromStream(FastSerialization.Deserializer)">
            <summary>
            Implementing IFastSerializable interface.  
            </summary>
        </member>
        <member name="T:Graphs.NodeIndex">
            <summary>
            Each node is given a unique index (which is dense: an array is a good lookup structure).   
            To avoid passing the wrong indexes to methods, we make an enum for each index.   This does
            mean you need to cast away this strong typing occasionally (e.g. when you index arrays)
            However on the whole it is a good tradeoff.  
            </summary>
        </member>
        <member name="T:Graphs.NodeTypeIndex">
            <summary>
            Each node nodeId is given a unique index (which is dense: an array is a good lookup structure).   
            To avoid passing the wrong indexes to methods, we make an enum for each index.   This does
            mean you need to cast away this strong typing occasionally (e.g. when you index arrays)
            However on the whole it is a good tradeoff.  
            </summary>    
        </member>
        <member name="T:Graphs.GraphUtils">
            <summary>
            Stuff that is useful but does not need to be in Graph.   
            </summary>
        </member>
        <member name="M:Graphs.GraphUtils.PrintGraph(Graphs.Graph)">
            <summary>
            Write the graph as XML to a string and return it (useful for debugging small graphs).  
            </summary>
            <returns></returns>
        </member>
        <member name="M:Graphs.GraphUtils.WriteXml(Graphs.Graph,System.IO.TextWriter)">
            <summary>
            Writes the graph as XML to 'writer'.  Don't use on big graphs.  
            </summary>
        </member>
        <member name="P:Graphs.MemoryGraph.Is64Bit">
            <summary>
            Indicates whether the memory addresses are 64 bit or not.   Note that this is not set
            as part of normal graph processing, it needs to be set by the caller.   MemoryGraph is only 
            acting as storage.  
            </summary>
        </member>
        <member name="P:Graphs.MemoryGraph.DistinctRefCount">
            <summary>
            Returns the number of distinct references in the graph so far (the size of the interning table).  
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraph.Clear">
            <summary>
            Clear puts it back into the state that existed after the constructor returned
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraph.GetNodeIndex(System.UInt64)">
            <summary>
            GetNodeIndex maps an Memory address of an object (used by CLRProfiler), to the NodeIndex we have assigned to it
            It is essentially an interning table (we assign it new index if we have  not seen it before)
            </summary>
        </member>
        <member name="F:Graphs.MemoryGraph.m_addressToNodeIndex">
            <summary>
            ClrProfiler identifes nodes  using the physical address in Memory.  'Graph' needs it to be an NodeIndex.   
            THis table maps the ID that CLRProfiler uses (an address), to the NodeIndex we have assigned to it.  
            It is only needed while the file is being read in.  
            </summary>
        </member>
        <member name="T:Graphs.MemoryNode">
            <summary>
            Support class for code:MemoryGraph
            </summary>
        </member>
        <member name="T:Graphs.MemoryNodeBuilder">
            <summary>
            MemoryNodeBuilder is helper class for building a MemoryNode graph.   Unlike
            MemoryNode you don't have to know the complete set of children at the time
            you create the node.  Instead you can keep adding children to it incrementally
            and when you are done you call Build() which finalizes it (and all its children)
            </summary>
        </member>
        <member name="M:Graphs.MemoryNodeBuilder.FindOrCreateChild(System.String,System.String)">
            <summary>
            Looks for a child with the type 'childTypeName' and returns it.  If it is not
            present, it will be created.  Note it will ONLY find MutableNode children
            (not children added with AddChild(NodeIndex).  
            </summary>
        </member>
        <member name="M:Graphs.MemoryNodeBuilder.AllocateTypeIndexes">
            <summary>
            This is optional phase, if you don't do it explicitly, it gets done at Build time. 
            </summary>
        </member>
        <member name="T:Graphs.ClrProfilerMemoryGraph">
            <summary>
            A MemoryGraph extends the basic Graph functionality to add the Memory addresses for each of the nodes, as well as understands
            how to read in CLRProfiler logs to form the graph.  
            
            See code:Graph for details on the general philosophy of design (keeping the graph small...)
            </summary>
        </member>
        <member name="M:Graphs.ClrProfilerMemoryGraph.Clear">
            <summary>
            Clear handles puts it back into the state that existed after the constructor returned
            </summary>
        </member>
        <member name="M:Graphs.ClrProfilerMemoryGraph.ClearWorker">
            <summary>
            ClearWorker does only that part of clear needed for this level of the hierarchy (and needs
            to be done by the constructor too). 
            </summary>
        </member>
        <member name="T:Graphs.MemoryGraphStackSource">
            <summary>
            code:MemorySampleSource hooks up a Memory graph to become a Sample source.  Currently we do
            a breadth-first traversal to form a spanning tree, and then create samples for each node
            where the 'stack' is the path to the root of this spanning tree.
            
            This is just a first cut...
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.#ctor(Graphs.Graph,System.IO.TextWriter,System.Single[])">
            <summary>
            Create a stack source from 'graph'.   samplingRatio is the ratio of size of the graph to 
            the size of the actual heap (if you only sampled part of it).   Counts are scaled by the 
            inverse of this so that the expected size of the graph works out. 
            
            log is were to send diagnostic messages (can be null)
            
            countMultipliers is an array (indexed by type Index), that will be used to multiply the
            counts in 'graph' when generating the stack source (thus if Type T has count 5 and 
            countMultipliers[T] = 10 then the stack source will return 50.   This is used to scale
            sampled graphs.   
            </summary>
        </member>
        <member name="P:Graphs.MemoryGraphStackSource.Graph">
            <summary>
            These methods let you get from the stack source abstraction to the underlying graph
            </summary>
        </member>
        <member name="P:Graphs.MemoryGraphStackSource.PriorityRegExs">
             <summary>
             Every type is given a priority of 0 unless the type name matches one of 
             the patterns in PriorityRegExs.  If it does that type is assigned that priority.
             
             A node's priority is defined to be the priority of the type of the node
             (as given by PriorityRegExs), plus 1/10 the priority of its parent.  
             
             Thus priorities 'decay' by 1/10 through pointers IF the prioirty of the node's
             type is 0 (the default).   
            
             By default the framework has a priority of -1 which means that you explore all
             high priority and user defined types before any framework type.
             
             Types with the same priority are enumerate breath-first.  
             </summary>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.RefCount(Graphs.NodeIndex)">
            <summary>
            Returns the number of references to the node represented by 'nodeIndex'.  The count will max out at 255 (but not wrap)
            </summary>
        </member>
        <member name="P:Graphs.MemoryGraphStackSource.SampleTimeRelativeMSecLimit">
            <summary>
            For graphs we use the address as a time, thus this returns the largest address in the memory heap.  
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.AddOrphansToQueue(PriorityQueue)">
            <summary>
            Add any unreachable nodes to the 'nodesToVisit'.   Note that we do this in a 'smart' way
            where we only add orphans that are not reachable from other orphans.   That way we get a 
            minimal set of orphan 'roots'.  
            </summary>
            <param name="nodesToVisit"></param>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.MarkDecendentsIgnoringCycles(Graphs.NodeIndex,System.Int32)">
            <summary>
            A helper for AddOrphansToQueue, so we only add orphans that are not reachable from other orphans.  
            
            Mark all decedents (but not nodeIndex itself) as being visited.    Any arcs that form
            cycles are ignored, so nodeIndex is guaranteed to NOT be marked.     
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.FreeNodeStorage(Graphs.Node)">
            <summary>
            Gives back nodes that are no longer in use.  This is a memory optimization. 
            </summary>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.AllocNodeStorage">
            <summary>
            Gets a node that can be written on.  It is a simple cache
            </summary>
            <returns></returns>
        </member>
        <member name="M:Graphs.MemoryGraphStackSource.ShortenNameSpaces(Graphs.NodeType)">
            <summary>
            Simulates having a 'default' name space.  This allows names to be significantly shorter. 
            </summary>
        </member>
        <member name="T:RefGraph">
            <summary>
            A RefGraph is derived graph where each node's children are the set of nodes in the original graph 
            which refer that node (that is A -> B then in refGraph B -> A).   
            
            The NodeIndexes in the refGraph match the NodeIndexes in the original graph.  Thus after creating
            a refGraph it is easy to answer the question 'who points at me' of the original graph.  
            
            When create the RefGraph the whole reference graph is generated on the spot (thus it must traverse
            the whole of the orignal graph) and the size of the resulting RefGraph is  about the same size as the  
            original graph. 
            
            Thus this is a fairly expensive thing to create.  
            </summary>
        </member>
        <member name="M:RefGraph.AllocNodeStorage">
            <summary>
            Allocates nodes to be used as storage for methods like code:GetNode, code:RefNode.GetFirstChild and code:RefNode.GetNextChild
            </summary>
        </member>
        <member name="M:RefGraph.GetNode(Graphs.NodeIndex,RefNode)">
            <summary>
            Given an arbitrary code:NodeIndex that identifies the node, Get a code:Node object.  
            
            This routine does not allocated but uses the space passed in by 'storage.  
            'storage' should be allocated with coode:AllocNodeStorage, and should be agressively reused.  
            </summary>
        </member>
        <member name="M:RefGraph.GetNode(Graphs.NodeIndex)">
            <summary>
            This is for debugging 
            </summary>
            <param name="nodeIndex"></param>
            <returns></returns>
        </member>
        <member name="M:RefGraph.AddRefsTo(Graphs.NodeIndex,Graphs.NodeIndex)">
            <summary>
            Add the fact that 'refSource' refers to refTarget.
            </summary>
        </member>
        <member name="M:RefGraph.AddLink(Graphs.NodeIndex,System.Int32)">
            <summary>
            A helper function for AddRefsTo.  Allocates a new cell from m_links and initializes its two fields 
            (the child index field and 'rest' field), and returns the index (pointer) to the new cell.  
            </summary>
        </member>
        <member name="T:RefGraph.NodeListIndex">
            <summary>
             Logically a NodeListIndex represents a list of node indexes.   However it is heavily optimized
             to avoid overhead.   0 means empty, a positive number is the NodeIndex+1 and a negative number 
             is index in m_links - 1;.  
            </summary>
        </member>
        <member name="T:RefGraph.RefElem">
            <summary>
            RefElem is a linked list cell that is used to store lists of childrens that are larger than 1.
            </summary>
        </member>
        <member name="F:RefGraph.m_refsForNodes">
            <summary>
            m_refsForNodes maps the NodeIndexs of the reference graph to the children information.   However unlike
            a normal Graph RefGraph needs to support incremental addition of children.  Thus we can't use the normal
            compression (which assumed you know all the children when you define the node).  
            
            m_refsForNodes points at a NodeListIndex which is a compressed list that is tuned for the case where
            a node has exactly one child (a very common case).   If that is not true we 'overflow' into a 'linked list'
            of RefElems that is stored in m_links.   See NodeListIndex for more on the exact encoding.   
            
            </summary>
        </member>
        <member name="F:RefGraph.m_links">
            <summary>
            If the number of children for a node is > 1 then we need to store the data somewhere.  m_links is array
            of linked list cells that hold the overflow case.  
            </summary>
        </member>
        <member name="M:RefNode.GetFirstChildIndex">
            <summary>
            Gets the first child for the node.  Will return null if there are no children.  
            </summary>
        </member>
        <member name="M:RefNode.GetNextChildIndex">
            <summary>
            Returns the next child for the node.   Will return NodeIndex.Invalid if there are no more children 
            </summary>
        </member>
        <member name="P:RefNode.ChildCount">
            <summary>
            Returns the count of children (nodes that reference this node). 
            </summary>
        </member>
        <member name="M:RefNode.Contains(Graphs.NodeIndex)">
            <summary>
            Returns true if 'node' is a child of 'this'.  childStorage is simply used as temp space 
            as was allocated by RefGraph.AllocateNodeStorage
            </summary>
        </member>
        <member name="T:SpanningTree">
            <summary>
            code:MemorySampleSource hooks up a Memory graph to become a Sample source.  Currently we do
            a breadth-first traversal to form a spanning tree, and then create samples for each node
            where the 'stack' is the path to the root of this spanning tree.
            
            This is just a first cut...
            </summary>
        </member>
        <member name="P:SpanningTree.PriorityRegExs">
             <summary>
             Every type is given a priority of 0 unless the type name matches one of 
             the patterns in PriorityRegExs.  If it does that type is assigned that priority.
             
             A node's priority is defined to be the priority of the type of the node
             (as given by PriorityRegExs), plus 1/10 the priority of its parent.  
             
             Thus priorities 'decay' by 1/10 through pointers IF the prioirty of the node's
             type is 0 (the default).   
            
             By default the framework has a priority of -1 which means that you explore all
             high priority and user defined types before any framework type.
             
             Types with the same priority are enumerate breath-first.  
             </summary>
        </member>
        <member name="M:SpanningTree.AddOrphansToQueue(PriorityQueue)">
            <summary>
            Add any unreachable nodes to the 'nodesToVisit'.   Note that we do this in a 'smart' way
            where we only add orphans that are not reachable from other orphans.   That way we get a 
            minimal set of orphan 'roots'.  
            </summary>
            <param name="nodesToVisit"></param>
        </member>
        <member name="M:SpanningTree.MarkDecendentsIgnoringCycles(Graphs.NodeIndex,System.Int32)">
            <summary>
            A helper for AddOrphansToQueue, so we only add orphans that are not reachable from other orphans.  
            
            Mark all decendents (but not nodeIndex itself) as being visited.    Any arcs that form
            cycles are ignored, so nodeIndex is guarenteed to NOT be marked.     
            </summary>
        </member>
        <member name="M:SpanningTree.FreeNodeStorage(Graphs.Node)">
            <summary>
            Gives back nodes that are no longer in use.  This is a memory optimization. 
            </summary>
        </member>
        <member name="M:SpanningTree.AllocNodeStorage">
            <summary>
            Gets a node that can be written on.  It is a simple cache
            </summary>
            <returns></returns>
        </member>
        <member name="M:SpanningTree.ToDotNetRegEx(System.String)">
            <summary>
            Convert a string from my regular expression format (where you only have * and {  } as grouping operators
            and convert them to .NET regular expressions string
            TODO FIX NOW cloned code (also in FilterStackSource)
            </summary>
        </member>
        <member name="T:PriorityQueue">
            <summary>
            TODO FIX NOW put in its own file.  
            A priority queue, specialized to be a bit more efficient than a generic version would be. 
            </summary>
        </member>
        <member name="T:GraphSampler">
            <summary>
            This class is responsible for taking a graph and generating a smaller graph that
            is a reasonable proxy.   In particular
                
                1) A spanning tree is formed, and if a node is selected so are all its 
                   parents in that spanning tree.
                   
                2) We try hard to keep scale each object type by the count by which the whole
                   graph was reduced.  
            </summary>
        </member>
        <member name="M:GraphSampler.#ctor(Graphs.MemoryGraph,System.Int32,System.IO.TextWriter)">
            <summary>
            
            </summary>
        </member>
        <member name="M:GraphSampler.GetSampledGraph">
            <summary>
            Creates a new graph from 'graph' which has the same type statistics as the original
            graph but keeps the node count roughly at 'targetNodeCount'
            </summary>
        </member>
        <member name="P:GraphSampler.CountScalingByType">
            <summary>
            returns an array of scaling factors.  This array is indexed by the type index of
            the returned graph returned by GetSampledGraph.   If the sampled count for that type multiplied
            by this scaling factor, you end up with the count for that type of the original unsampled graph.  
            </summary>
        </member>
        <member name="M:GraphSampler.MapTypeIndex(Graphs.NodeTypeIndex)">
            <summary>
            Maps 'oldTypeIndex' to its type index in the output graph
            </summary>
            <returns>New type index, will be Invalid if the type is not in the output graph</returns>
        </member>
        <member name="M:GraphSampler.MapNodeIndex(Graphs.NodeIndex)">
            <summary>
            Maps 'oldNodeIndex' to its new node index in the output graph
            </summary>
            <returns>New node index, will be less than 0 if the node is not in the output graph</returns>
        </member>
        <member name="M:GraphSampler.VisitNode(Graphs.NodeIndex,System.Boolean,System.Boolean)">
            <summary>
            Visits 'nodeIdx', if already visited, do nothing.  If unvisited determine if 
            you should add this node to the graph being built.   If 'mustAdd' is true or
            if we need samples it keep the right sample/total ratio, then add the sample.  
            </summary>
        </member>
        <member name="M:GraphSampler.GetNewTypeIndex(Graphs.NodeTypeIndex)">
            <summary>
            Maps 'oldTypeIndex' to its type index in the output graph
            </summary>
            <param name="oldTypeIndex"></param>
            <returns></returns>
        </member>
        <member name="F:GraphSampler.RejectedNode">
            <summary>
            This value goes in the m_newIndex[].   If we accept the node into the sampled graph, we put the node
            index in the NET graph in m_newIndex.   If we reject the node we use the special RegjectedNode value
            below
            </summary>
        </member>
        <member name="F:GraphSampler.PotentialNode">
            <summary>
            This value also goes in m_newIndex[].   If we can add this node without needing to add any other nodes
            to the new graph (that is it is one hop from an existing accepted node, then we mark it speically as
            a PotentialNode).    
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.DirectoryUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system directories. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String)">
            <summary>
            SafeCopy sourceDirectory to directoryToVersion recursively. The target directory does
            no need to exist
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Copy(System.String,System.String,System.IO.SearchOption)">
            <summary>
            SafeCopy all files from sourceDirectory to directoryToVersion.  If searchOptions == AllDirectories
            then the copy is recursive, otherwise it is just one level.  The target directory does not
            need to exist. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.Clean(System.String)">
            <summary>
            Clean is sort of a 'safe' recursive delete of a directory.  It either deletes the
            files or moves them to '*.deleting' names.  It deletes directories that are completely
            empty.  Thus it will do a recursive delete when that is possible.  There will only 
            be *.deleting files after this returns.  It returns the number of files and directories
            that could not be deleted.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.DeleteOldest(System.String,System.Int32)">
            <summary>
            Removes the oldest directories directly under 'directoryPath' so that 
            only 'numberToKeep' are left. 
            </summary>
            <param variable="directoryPath">Directory to removed old files from.</param>
            <param variable="numberToKeep">The number of files to keep.</param>
            <returns> true if there were no errors deleting files</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String,System.IO.SearchOption)">
             <summary>
             DirectoryUtilities.GetFiles is basicaly the same as Directory.GetFiles 
             however it returns IEnumerator, which means that it lazy.  This is very important 
             for large directory trees.  A searchPattern can be specified (Windows wildcard conventions)
             that can be used to filter the set of archiveFile names returned. 
             
             Suggested Usage
             
                 foreach(string fileName in DirectoryUtilities.GetFiles("c:\", "*.txt")){
                     Console.WriteLine(fileName);
                 }
            
             </summary>
             <param variable="directoryPath">The base directory to enumerate</param>
             <param variable="searchPattern">A pattern to filter the names (windows filename wildcards * ?)</param>
             <param variable="searchOptions">Indicate if the search is recursive or not.  </param>
             <returns>The enumerator for all archiveFile names in the directory (recursively). </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.DirectoryUtilities.GetFiles(System.String,System.String)">
            <summary>
            Returns a lazy enumerable for every path in 'directoryName' that matchs 'searchPattern' (default is *)MO
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.FileUtilities">
            <summary>
            General purpose utilities dealing with archiveFile system files. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ReadAllLines(System.String)">
            <summary>
            GetLines works much like File.ReadAllLines, however instead of returning a
            array of lines, it returns a IEnumerable so that the archiveFile is not read all
            at once.  This allows 'foreach' syntax to be used on very large files.  
            
            Suggested Usage
            
                foreach(string lineNumber in FileUtilities.GetLines("largeFile.txt")){
                    Console.WriteLine(lineNumber);
                }
            </summary>
            <param variable="fileName">The base directory to enumerate.</param>
            <returns>The enumerator for all lines in the archiveFile.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ExpandWildcards(System.String[],System.IO.SearchOption)">
            <summary>
            Given archiveFile specifications possibly with wildcards in them
            Returns an enumerator that returns each expanded archiveFile name in turn. 
            
            If searchOpt is AllDirectories it does a recursive match. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceDelete(System.String)">
            <summary>
            Delete works much like File.Delete, except that it will succeed if the
            archiveFile does not exist, and will rename the archiveFile so that even if the archiveFile 
            is locked the original archiveFile variable will be made available.  
            
            It renames the  archiveFile with a '[num].deleting'.  These files might be left 
            behind.  
            
            It returns true if it was completely successful.  If there is a *.deleting
            archiveFile left behind, it returns false. 
            </summary>
            <param variable="fileName">The variable of the archiveFile to delete</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.TryDelete(System.String)">
            <summary>
            Try to delete 'fileName' catching any exception.  Returns true if successful.   It will delete read-only files.  
            </summary>  
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceCopy(System.String,System.String)">
            <summary>
            SafeCopy sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.ForceMove(System.String,System.String)">
            <summary>
            Moves sourceFile to destinationFile.  If the destination exists
            used ForceDelete to get rid of it first.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.FileUtilities.Equals(System.String,System.String)">
            <summary>
            Returns true if the two file have exactly the same content (as a stream of bytes). 
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.PathUtil">
            <summary>
            Utilities associated with file name paths. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.PathUtil.PathRelativeTo(System.String,System.String)">
            <summary>
            Given a path and a superdirectory path relativeToDirectory compute the relative path (the path from) relativeToDirectory
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.XmlUtilities">
            <summary>
            The important thing about these general utilities is that they have only dependencies on mscorlib and
            System (they can be used from anywhere).  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.OpenXmlElement(System.String)">
            <summary>
            Given an XML element, remove the closing operator for it, so you can add new child elements to it by concatination. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlEscape(System.Object,System.Boolean)">
            <summary>
            Given an object 'obj' do ToString() on it, and then transform it so that all speical XML characters are escaped and return the result. 
            If 'quote' is true also surround the resulting object with double quotes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Object)">
            <summary>
            A shortcut for XmlEscape(obj, true) (that is ToString the object, escape XML chars, and then surround with double quotes. 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuote(System.Int32)">
            <summary>
            Create a doubly quoted string for the decimal integer value
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.UInt64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int32)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Utilities.XmlUtilities.XmlQuoteHex(System.Int64)">
            <summary>
            Create a double quoted string for the hexidecimal value of 'value'
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Utilities.TeeTextWriter">
            <summary>
            This class returns a stream, which when written to, will write to two other streams.  
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLWriter">
            <summary>
            ZippedETLWriter is a helper class used to compress ETW data (ETL files)
            along with symbolic information (e.g. NGEN pdbs), as well as other optional
            metadata (e.g. collection log files), into a single archive ready for 
            transfer to another machine.   
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to write a new ZIP archive that will
            contain ETW file 'etlFilePath' in it as well as symbolic information (NGEN
            pdbs) and possibly other information.   log is a Text stream to send detailed
            information to.  
            <para>
            This routine assumes by default (unless Merge is set to false) that the ETL 
            file needs to be merged before it is archived.   It will also generate all
            the NGEN pdbs needed for the archive.   
            </para>
            <para>
            You must call the WriteArchive method before any operations actually happen. 
            Up to that point is is just remembering instructions for WriteArchive to
            follow.  
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.ZipArchivePath">
            <summary>
            This is the name of the output archive.  By default is the same as the ETL file name 
            with a .zip' suffix added (thus it will typically be .etl.zip).  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Log">
            <summary>
            If set this is where messages about progress and detailed error information goes.  
            While you dont; have to set this, it is a good idea to do so.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.AddFile(System.String,System.String)">
            <summary>
            By default ZippedETL file will zip the ETL file itself and the NGEN pdbs associated with it.
            You can add additional files to the archive by calling AddFile.   In specififed 'archivePath' 
            is the path in the archive and defaults to just the file name of the original file path.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.WriteArchive(System.IO.Compression.CompressionLevel)">
            <summary>
            Actually do the work specified by the ZippedETLWriter constructors and other methods.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.SymbolReader">
            <summary>
            This is the symbol reader that is used to generate the NGEN Pdbs as needed
            If it is not specififed one is created on the fly.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Merge">
            <summary>
            By default the ETL file is merged before being added to the archive.  If
            this is not necessary, you can set this to false.   
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.CompressETL">
            <summary>
            Uses a compressed format for the ETL file.   Normally off.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.NGenSymbolFiles">
            <summary>
            By default the symbol files (PDBs) are included in the ZIP file.   If this
            is not desired for whatever reason, this property can be set to false.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.Zip">
            <summary>
            Normally WriteArchive creates a ZIP archive.  However it is possible that you only wish
            to do the merging and NGEN symbol generation.   Setting this property to false
            will supress the final ZIP operation.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLWriter.DeleteInputFile">
            <summary>
            Normally if you ZIP you will delete the original ETL file.  Setting this to false overrides this.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLWriter.GetNGenPdbs(System.String,Microsoft.Diagnostics.Symbols.SymbolReader,System.IO.TextWriter)">
            <summary>
            Returns the list of path names to the NGEN pdbs for any NGEN image in 'etlFile' that has
            any samples in it.   
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Tracing.ZippedETLReader">
            <summary>
            ZippedETLReader is a helper class that unpacks the ZIP files generated
            by the ZippedETLWriter class.    It can be smart about placing the 
            symbolic information in these files on the SymbolReader's path so that
            symbolic lookup 'just works'.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Declares the intent to unzip an .ETL.ZIP file that contain an compressed ETL file 
            (and NGEN pdbs) from the archive at 'zipFilePath'.   If present, messages about
            the unpacking go to 'log'.   Note that this unpacking only happens when the
            UnpackArchive() method is called.  
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.Log">
            <summary>
            If set messages about unpacking go here. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.EtlFileName">
            <summary>
            The name of hte ETL file to extract (it is an error if there is not exactly 1).  
            If not present it is derived by changing the extension of the zip archive. 
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Tracing.ZippedETLReader.SymbolDirectory">
            <summary>
            Where to put the symbols.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.ZippedETLReader.UnpackAchive">
            <summary>
            After setting any properties to override default behavior, calling this method
            will actually do the unpacking.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Tracing.Parsers.MicrosoftWindowsNDISPacketCapture.PacketFragmentArgs.AppendPrintable(System.Byte*,System.Byte*,System.Text.StringBuilder,System.String,System.Int32)">
            <summary>
            Sees if up to 'max' bytes of frag-fragend is a printable string and if so prints it to 'sb' with 
            'prefix' before it.  
            </summary>
        </member>
        <member name="T:Utilities.ConfigData">
            <summary>
            ConfigData is simply a Dictionary that knows how to read and write itself to XML efficiently. 
            </summary>
        </member>
        <member name="T:Utilities.DatabindingDebugConverter">
            <summary>
            This converter does nothing except breaking the debugger into the convert method
            </summary>
        </member>
        <member name="T:Utilities.CacheFiles">
            <summary>
            Some applications need to make files that are associated with the application
            but also have affinity with other files on the disk.   This class helps manage this
            </summary>
        </member>
        <member name="M:Utilities.CacheFiles.FindFile(System.String,System.String)">
            <summary>
            Find a path name for the file 'baseFilePath' (which can be a path name to anywhere).
            which has the extension 'extension'.  It will always return something in 'CacheDir'
            and thus might go away.
            </summary>
            <remarks>
            Note that the file 'baseFilePath' is assumed to exist.
            </remarks>
        </member>
        <member name="M:Utilities.CacheFiles.UpToDate(System.String,System.String)">
            <summary>
            Returns true if the output file is up to date with respect to the input file (exists and created after it). 
            </summary>
        </member>
        <member name="T:Utilities.CommandLineParser">
            <summary>
            see code:#Overview for more 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.ParseForConsoleApplication(System.Action{Utilities.CommandLineParser})">
            <summary>
            If you are building a console Application, there is a common structure to parsing arguments. You want
            the text formated and output for console windows, and you want /? to be wired up to do this. All
            errors should be caught and displayed in a nice way.  This routine does this 'boiler plate'.  
            </summary>
            <param name="parseBody">parseBody is the body of the parsing that this outer shell does not provide.
            in this delegate, you should be defining all the command line parameters using calls to Define* methods.
             </param>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineOptionalQualifier``1(System.String,``0@,System.String)">
            <summary>
            Qualifiers are command line parameters of the form -NAME:VALUE where NAME is an alphanumeric name and
            VALUE is a string. The parser also accepts -NAME: VALUE and -NAME VALUE but not -NAME : VALUE For
            boolan parameters, the VALUE can be dropped (which means true), and a empty string VALUE means false.
            Thus -NAME means the same as -NAME:true and -NAME: means the same as -NAME:false (and boolean
            qualifiers DONT allow -NAME true or -NAME false).
            
            The types that are supported are any type that has a static 'Parse' function that takes a string
            (this includes all primitive types as well as DateTime, and Enumerations, as well as arrays of
            parsable types (values are comma separated without space).
            
            Qualifiers that are defined BEFORE any parameter sets apply to ALL parameter sets.  qualifiers that
            are defined AFTER a parameter set will apply only the the parameter set that preceeds them.  
            
            See code:#DefiningParametersAndQualifiers
            See code:#Overview 
            <param name="name">The name of the qualifer.</param>
            <param name="retVal">The place to put the parsed value</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param>
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineQualifier``1(System.String,``0@,System.String)">
            <summary>
            Like code:DeclareOptionalQualifier except it is an error if this parameter is not on the command line. 
            <param name="name">The name of the qualifer.</param>
            <param name="retVal">The place to put the parsed value</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineAliases(System.String,System.String[])">
            <summary>
            Specify additional aliases for an qualifier.  This call must come BEFORE the call to
            Define*Qualifier, since the definition needs to know about its aliases to do its job.  
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineParameter``1(System.String,``0@,System.String)">
            <summary>
            DefineParameter declares an unnamed parameter (basically any parameter that is not a
            qualifier). These are given ordinal numbers (starting at 0). You should declare the parameter in the
            desired order.
            
            See code:#DefiningParametersAndQualifiers
            See code:#Overview 
            <param name="name">The name of the parameter.</param>
            <param name="retVal">The place to put the parsed value</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineOptionalParameter``1(System.String,``0@,System.String)">
            <summary>
            Like code:DeclareParameter except it is an error if this parameter is not on the command line. 
            These must come after non-optional (required) parameters. 
            </summary>
            <param name="name">The name of the parameter</param>
            <param name="retVal">The location to place the parsed value.</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
        </member>
        <member name="M:Utilities.CommandLineParser.DefineParameterSet``1(System.String,``0@,``0,System.String)">
            <summary>
            A parameter set defines on of a set of 'commands' that decides how to parse the rest of the command
            line.   If this 'command' is present on the command line then 'val' is assigned to 'retVal'. 
            Typically 'retVal' is a variable of a enumerated type (one for each command), and 'val' is one
            specific value of that enumeration.  
            
            * See code:#ParameterSets
            * See code:#DefiningParametersAndQualifiers
            * See code:#Overview 
            <param name="name">The name of the parameter set.</param>
            <param name="retVal">The place to put the parsed value</param> 
            <param name="val">The value to place into 'retVal' if this parameter set is indicated</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineDefaultParameterSet(System.String)">
            <summary>
            There is one special parameter set called the default parameter set (whose names is empty) which is
            used when a command line does not have one of defined parameter sets. It is always present, even if
            this method is not called, so calling this method is optional, however, by calling this method you can
            add help text for this case.  If present this call must be AFTER all other parameter set
            definitions. 
            
            * See code:#DefaultParameterSet 
            * See code:#DefiningParametersAndQualifiers
            * See code:#Overview
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineDefaultParameterSet``1(``0@,``0,System.String)">
            <summary>
            This variation of DefineDefaultParameterSet has a 'retVal' and 'val' parameters.  If the command
            line does not match any of the other parameter set defintions, then 'val' is asigned to 'retVal'. 
            Typically 'retVal' is a variable of a enumerated type and 'val' is a value of that type.    
            
            * See code:DefineDefaultParameterSet for more.
            <param name="retVal">The place to put the parsed value</param> 
            <param name="val">The value to place into 'retVal' if this parameter set is indicated</param>
            <param name="helpText">Text to print for this qualifer.  It will be word-wrapped.  Newlines indicate
            new paragraphs.</param> 
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.NoDashOnParameterSets">
            <summary>
            By default parameter set specifiers must look like a qualifer (begin with a -), however setting
            code:NoDashOnParameterSets will define a parameter set marker not to have any special prefix (just
            the name itself.  
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.ParameterSetsWhereQualifiersMustBeFirst">
            <summary>
            If the positional parameters might look like named parameters (typically happens when the tail of the
            command line is literal text), it is useful to stop the search for named parameters at the first
            positional parameter. 
            
            Because some parameters sets might want this behavior and some might not, you specify the list of
            parameter sets that you want to opt in.
            
            The expectation is you do something like
                * commandLine.ParameterSetsWhereQualifiersMustBeFirst = new string[] { "parameterSet1" };
                
            The empty string is a wildcard that indicats all parameter sets have the qualifiersMustBeFirst 
            attribute.   This is the only way to get this attribute on the default parameter set.  
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.QualifiersUseOnlyDash">
            <summary>
            By default qualifiers may being with a - or a / character.   Setting code:QualifiersUseOnlyDash will
            make / invalid qualifer marker (only - can be used)
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.NoSpaceOnQualifierValues">
            <summary>
            By default, the syntax (-Qualifier:Value) and (-Qualifer Value) are both allowed.   However
            this makes it impossible to use -Qualifier to specify that a qualifier is present but uses
            a default value (you have to use (-Qualifier: )) Specifying code:NoSpaceOnQualifierValues
            indicates that the syntax (-Qualifer ObjectEnumerator) is not allowed, which allows this.  
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.LastQualiferWins">
            <summary>
            By default, a non-list qualifier can not be specified more than once (since one or the other will
            have to be ignored).  Normally an error is thrown.  Setting code:LastQualiferWins makes it legal, and
            the last qualifer is the one that is used.  
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.CompleteValidation">
            <summary>
            Check for any parameters that the user specified but that were not defined by a Define*Parameter call
            and throw an exception if any are found. 
            
            Returns true if validation was completed.  It can return false (rather than throwing), If the user
            requested help (/?).   Thus if this routine returns false, the 'GetHelp' should be called.
            </summary>
        </member>
        <member name="P:Utilities.CommandLineParser.HelpRequested">
            <summary>
            Returns non-null if the user specified /? on the command line.   returns the word after /? (which may be the empty string)
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.GetHelp(System.Int32,System.String,System.Boolean)">
            <summary>
            Return the string representing the help for a single paramter set.  If displayGlobalQualifiers is
            true than qualifiers that apply to all parameter sets is also included, otheriwse it is just the
            parameters and qualifiers that are specific to that parameters set. 
            
            If the parameterSetName null, then the help for the entire program (all parameter
            sets) is returned.  If parameterSetName is not null (empty string is default parameter set),
            then it generates help for the parameter set specified on the command line.
            
            Since most of the time you don't need help, helpInformatin is NOT collected during the Define* calls
            unless HelpRequested is true.   If /? is seen on the command line first, then this works.  You can
            also force this by setting HelpRequested to True before calling all the Define* APIs. 
            
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.ParseWords(System.String)">
            <summary>
            Parses 'commandLine' into words (space separated items).  Handles quoting (using double quotes)
            and handles escapes of double quotes and backslashes with the \" and \\ syntax.  
            In theory this mimics the behavior of the parsing done before Main to parse the command line into
            the string[].  
            </summary>
            <param name="commandLine"></param>
        </member>
        <member name="M:Utilities.CommandLineParser.ParseWordsIntoQualifiers">
            <summary>
            Find the locations of all arguments that look like named parameters. 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.IsQualifier(System.String)">
            <summary>
            Returns true if 'arg' is a qualiier begins with / or -
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.ParseParameterName(System.String)">
            <summary>
            Qualifiers have the syntax -/NAME=Value.  This returns the NAME
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DefineQualifier(System.String,System.Type,System.Object,System.String,System.Boolean)">
            <summary>
            returns the index in the 'args' array of the next instance of the 'name' qualifier.   returns -1 if there is 
            no next instance of the qualifer.  
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.ParseCompositeEnumValue(System.String,System.Type,System.String)">
            <summary>
            Enums that are bitfields can have multiple values.  Support + and - (for oring and diffing bits).  Returns
            the final enum value.  for the 'valueString' which is a string form of 'type' for the parameter 'parameter'.  
            </summary>
        </member>
        <member name="T:Utilities.CommandLineParser.CommandLineParameter">
            <summary>
            CommandLineParameter contains the 'full' informaiton for a parameter or qualifier used for generating help.
            Most of the time we don't actualy generate instances of this class.  (see mustParseHelpStrings)
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.GetFullHelp(System.Int32)">
            <summary>
            Return a string giving the help for the command, word wrapped at 'maxLineWidth' 
            </summary>
        </member>
        <member name="M:Utilities.CommandLineParser.DisplayStringToConsole(System.String)">
            <summary>
            prints a string to the console in a nice way.  In particular it 
            displays a sceeen full of data and then as user to type a space to continue. 
            </summary>
            <param name="helpString"></param>
        </member>
        <member name="F:Utilities.CommandLineParser.aliasDefinitions">
            <summary>
            qualifiers can have aliases (e.g. for short names).  This holds these aliases.  
            </summary>
        </member>
        <member name="T:Utilities.CommandLineParserException">
            <summary>
            Run time parsing error throw this exception.   These are expected to be caught and the error message
            printed out to the user.   Thus the messages should be 'user friendly'.  
            </summary>
        </member>
        <member name="T:Utilities.CommandLineParserDesignerException">
            <summary>
            This exception represents a compile time error in the command line parsing.  These should not happen in
            correctly written programs.
            </summary>
        </member>
        <member name="M:Utilities.CommandLineUtilities.FormCommandLineFromArguments(System.String[],System.Int32)">
            <summary>
            Given a list of arguments, from 'startAt' to the end of 'arguments' quote any 
            arguments that have spaces in them so that the resulting command lineNumber has 
            been turned back into a string that could be passed to a subprocess.
            </summary>
            <param variable="arguments">The command lineNumber arguments parsed as space sparated token.</param>
            <param variable="startAt">The sampleIndex in 'arguments' of the sub-array of interest (typically 0).</param>
            <returns>
            A string that represents the original commannd lineNumber string before being parsed 
            into array of space separated arguments 
            </returns>
        </member>
        <member name="M:Utilities.ExceptionMessage.GetUserMessage(System.Exception,System.Boolean@)">
            <summary>
            Figures out a good user message for the exception 'e'   For things that directly
            relate to user actions we simply print the message, for everything else we print
            a detailed diagnostic message.  We set 'userLevel' to which one it was.  
            </summary>
        </member>
        <member name="T:Utilities.SupportFiles">
            <summary>
            SupportFiles is a class that manages the unpacking of DLLs and other resources.  
            This allows you to make your EXE the 'only' file in the distribution, and all other
            files are unpacked from that EXE.   
            
            To add a file to the EXE as a resource you need to add the following lines to the .csproj
            In the example below we added the TraceEvent.dll file (relative to the project directory).
            LogicalName must start with a .\ and is the relative path from the SupportFiles directory
            where the file will be placed.  Adding the Link tag makes it show up in a pretty way in
            solution explorer.  
            
            <ItemGroup>
             <EmbeddedResource Include="..\TraceEvent\$(OutDir)Microsoft.Diagnostics.Tracing.TraceEvent.dll">
              <Type>Non-Resx</Type>
              <WithCulture>false</WithCulture>
              <LogicalName>.\TraceEvent.dll</LogicalName>
             </EmbeddedResource>
            </ItemGroup>
            
            By default SupportFiles registers an Assembly resolve helper so that if you reference
            any DLLs in the project the .NET runtime will look for them in the support files directory. 
            
            You just need to be careful to call 'UnpackResourcesIfNeeded' in your Main method and 
            don't use any of your support DLLs in the main method itself (you can use it in any method
            called from main).   If necessary, put everything in a 'MainWorker' method except the 
            call to UnpackResourcesIfNeeded.
            
            Everything you deploy goes in its own version directory where the version is the timestamp
            of the EXE.   Thus newer version of your EXE can run with an older version and they don't
            cobber each other.    Newer version WILL delete older version by only if the directory
            is unlocked (no-one is using it).   Thus there tends to only be one version. 
            
            While UnpackResourcesIfNeeded will keep only one version it will not clean it up to
            zero.  You have to write your own '/uninstall' or 'Cleanup' that deletes SupportFileDir
            if you want this.  
            </summary>
        </member>
        <member name="M:Utilities.SupportFiles.UnpackResourcesIfNeeded(System.Boolean)">
            <summary>
            Unpacks any resource that beginning with a .\ (so it looks like a relative path name)
            Such resources are unpacked into their relative position in SupportFileDir. 
            'force' will force an update even if the files were unpacked already (usually not needed)
            The function returns true if files were unpacked.  
            </summary>
        </member>
        <member name="P:Utilities.SupportFiles.SupportFileDir">
            <summary>
            SupportFileDir is a directory that is reserved for CURRENT VERSION of the software (if a later version is installed)
            It gets its own directory).   This is the directory where files in the EXE get unpacked to.  
            </summary>
        </member>
        <member name="P:Utilities.SupportFiles.SupportFileDirBase">
            <summary>
            You must have write access to this directory.  It does not need to exist, but 
            if not, users have to have permission to create it.   This directory should only
            be used for this app only (not shared with other things).    By default we choose
            %APPDATA%\APPNAME where APPNAME is the name of the application (EXE file name 
            without the extension). 
            </summary>
        </member>
        <member name="P:Utilities.SupportFiles.ExePath">
            <summary>
            The path to the executable.   You should not be writing here! that is what SupportFileDir is for.  
            </summary>
        </member>
        <member name="P:Utilities.SupportFiles.ProcessArch">
            <summary>
            Get the name of the architecture of the current process
            </summary>
        </member>
        <member name="M:Utilities.SupportFiles.LoadNative(System.String)">
            <summary>
            If you need to load an unmanaged DLL that is part of your distribution
            This routine will do the load library using the correct architecture
            </summary>
            <param name="relativePath"></param>
        </member>
        <member name="M:Utilities.SupportFiles.AddManagedDllSearchPath(System.String)">
            <summary>
            This allows you to add a directory that will be searched when looking up managed DLLs.
            It is useful to do this to find DLLs used for extensibility.  
            </summary>
        </member>
        <member name="M:Utilities.SupportFiles.LoadLibrary(System.String)">
            <summary>
            This is a convinience function.  If you unpack native dlls, you may want to simply LoadLibary them
            so that they are guarenteed to be found when needed.  
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.CommandEnvironment">
            <summary>
            CommandEnvironment defines the 'primitive starting points' that a PerfView Extension uses
            to start doing interesting things.   
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.LogFile">
            <summary>
            The log file is a place to write verbose diagnostics.  It is either the console or the GUI log, or
            a file that use redirected logging to with the /logFile=XXX qualifier.
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenETLFile(System.String)">
            <summary>
            Open an ETL file (same as new TraceLog(etlFileName))
            </summary>
            <param name="etlFileName"></param>
            <returns></returns>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenPerfViewXmlFile(System.String)">
            <summary>
            Opens a *.perfView.xml.zip or *.perfview.xml 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenGCDumpFile(System.String)">
            <summary>
            Opens a GCHeap dump (created with HeapSnapshot)
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.Run(System.String,System.String,PerfView.CommandLineArgs)">
            <summary>
            Runs the command 'commandLine' with ETW enabled.   Creates  data file 'outputFileName'.  
            By default this is a Zipped ETL file.  
            </summary>  
            <param name="commandLine">The command line to run.</param>
            <param name="dataFile">The data file to place the profile data.  If omitted it is the parsedParams.DataFile</param>
            <param name="parsedCommandLine">Any other arguments for the run command.  
            If omitted it is inherited from the CommandEnvironment.CommandLineArgs </param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.Collect(System.String,PerfView.CommandLineArgs)">
            <summary>
            Run the 'Collect command creating the data file outputFileName.  By default this is a Zipped ETL file.  
            </summary>
            <param name="dataFile">The data file to place the profile data.  If omitted it is the parsedParams.DataFile</param>
            <param name="parsedCommandLine">Any other arguments for the run command.  
            If ommited it is inherited from the CommandEnvironment.CommandLineArgs </param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.HeapSnapshot(System.String,System.String)">
            <summary>
            Collect a heap snapshot from 'process' placing the data in 'outputFileName' (a gcdump file)
            </summary>
            <param name="process">The name of the process or the process ID.  
            If there is more than one process with the same name, the one that was started LAST is chosen. </param>
            <param name="outputFileName">The data file (.gcdump) to generate.</param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.HeapSnapshotFromProcessDump(System.String,System.String)">
            <summary>
            Collect a heap snapshot from a process dump file 'dumpFile'  placing the data in 'outputFileName' (a gcdump file)
            </summary>
            <param name="inputDumpFile">The dump file to extract the heap from.</param>
            <param name="outputFileName">The data file (.gcdump) to generate. </param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenStackViewer(PerfViewExtensibility.Stacks,System.Action{PerfView.StackWindow})">
            <summary>
            Open a new stack viewer GUI window in the dat in 'stacks'
            </summary>
            <param name="stacks"></param>
            <param name="OnOpened"></param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenEventViewer(PerfViewExtensibility.Events,System.Action{PerfView.EventWindow})">
            <summary>
            Open a new EventViewer with the given set of events
            </summary>
            <param name="events"></param>
            <param name="OnOpened">If non-null an action to perform after the window is opened (on the GUI thread)</param>
            <returns></returns>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenHtmlReport(System.String,System.String,System.Action{System.String,System.IO.TextWriter,PerfView.GuiUtilities.WebBrowserWindow},System.Action{PerfView.GuiUtilities.WebBrowserWindow})">
            <summary>
            Displays an HTML file htmlFilePath, (typically created using CommandEnvironment.CreateUniqueCacheFileName()) 
            in a new window.  
            </summary>
            <param name="htmlFilePath">The path to the file containing the HTML.</param>
            <param name="title">The title for the new window.</param>
            <param name="DoCommand">Docommand(string command, TextWriter log), is a action that is called any time a URL of the
            form <a href="command:XXXX"></a> is clicked on.   The XXXX is passed as the command and a TextWriter that can display
            messages to the windows log is given, and a handle to the web browser window itself.   Messages surrounded by [] in 
            the log are also displayed on the windows one line status bar.   Thus important messages should be surrounded by [].   
            This callback is NOT on the GUI thread, so you have to use the window.Dispatcher.BeginInvoke() to cause actions on 
            the GUI thread.</param>
            <param name="OnOpened">If non-null an action to perform after the window is opened (on the GUI thread)</param>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenExcel(System.String)">
            <summary>
            Open Excel on csvFilePath.   
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.OpenLog">
            <summary>
            Opens the log window if this is running under the GUI, otherwise does nothing.  
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.CommandLineArgs">
            <summary>
            The command lines passed to perfView itself.  These are also populated by default values.
            Setting these values in CommandLineArgs will cause the commands below to use the updated values. 
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.ConfigData">
            <summary>
            ConfigData is a set of key-value dictionary that is persisted (as AppData\Roaming\PerfView\UserConfig.xml)
            so it is remembered across invocations of the program.  
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.CacheFileDirectory">
            <summary>
            This is a directory where you can place temporary files.   These files will be cleaned up
            eventually if the number grows too large.   (this is %TEMP%\PerfView)
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.CommandEnvironment.CreateUniqueCacheFileName(System.String,System.String)">
            <summary>
            Creates a file name that is in the CacheFileDirectory that will not collide with any other file.  
            You give it the base name (file name without extension), as well as the extension, and it returns
            a full file path that is guaranteed to be unique.  
            </summary>
            <param name="baseFilePath">The file name without extension (a suffix will be added to this)</param>
            <param name="extension">optionally an extension to add to the file name (must have a . in front)</param>
            <returns>The full path of a unique file in the CacheFileDirectory</returns>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.ExtensionsDirectory">
            <summary>
            This is the directory that all extensions live in (e.g. PerfViewExtensibity next to PerfView.exe)
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.CommandEnvironment.SupportFilesDirectory">
            <summary>
            This is the directory where support files can go (.e.g AppData\Roaming\PerfView\VER.*)
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.DataFile.FilePath">
            <summary>
            The path of the data file
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.ETLDataFile">
            <summary>
            ETL file is a simplified wrapper over the TraceLog class, which represents an ETL data file.
            If you need 'advanced' features access the TraceLog property.  
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.ETLDataFile.Processes">
            <summary>
            ETL files collect machine wide, but it is good practice to focus on a particular process
            as quickly as possible.   TraceProcesses is a shortcut to TraceLog.Process that let you
            find a process of interest quickly.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.CPUStacks(System.Boolean)">
            <summary>
            If the ETL file has stack samples, fetch them.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.ThreadTimeStacks(System.Boolean)">
            <summary>
            If the ETL file has stack samples, fetch them.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.ThreadTimeWithTasksStacks(System.Boolean)">
            <summary>
            If the ETL file has stack samples, fetch them as an activity aware stack source.
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.ETLDataFile.Events">
            <summary>
            Get the list of raw events.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.#ctor(System.String,System.Action{System.Boolean,System.Int32,System.Int32})">
            <summary>
            Open an existing ETL file by name
            </summary>
            <param name="fileName">The name of the ETL file to open</param>
            <param name="onLostEvents">If non-null, this method is called when there are lost events (with the count of lost events)</param>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.LookupSymbolsForModule(System.String,Microsoft.Diagnostics.Symbols.SymbolReaderOptions)">
            <summary>
            Lookup all symbols for any module with 'simpleFileName'.   If processID==0 then all processes are searched. 
            </summary>
            <param name="simpleModuleName">The name of the module without directory or extension</param>
            <param name="symbolFlags">Options for symbol reading</param>
        </member>
        <member name="P:PerfViewExtensibility.ETLDataFile.TraceLog">
            <summary>
            Access the underlying TraceLog class that actually represents the ETL data.   You use
            when the simplified wrappers are not sufficient.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.GetSymbolReader(Microsoft.Diagnostics.Symbols.SymbolReaderOptions)">
            <summary>
            Returns a SymbolReader which knows to look in local places associated with this file as well
            as the user defined places. 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.ETLDataFile.Dispose">
            <summary>
            Closes the file (so for example you could update it after this)
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Events.EscapeForCsv(System.String,System.String)">
            <summary>
            Returns a string that is will be exactly one field of a CSV file.  Thus it escapes , and ""
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.Stacks">
            <summary>
            A Stacks class represents what the PerfView 'stacks' view shows you.   It has 
            a 'FilterParams' property which represents all the filter strings in that view.  
            It also has properties that represent the various tabs in that view (calltee, byname ...)
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.LookupWarmSymbols(System.Int32,Microsoft.Diagnostics.Symbols.SymbolReaderOptions)">
            <summary>
            Resolve the symbols of all modules that have at least 'minCount' INCLUSIVE samples.  
            symbolFlags indicate how aggressive you wish to be.   By default it is aggressive as possible (do 
            whatever you need to get the PDB you need).  
            Setting 'minCount' to 0 will try to look up all symbols possible (which is relatively expensive). 
            
            By default all Warm symbols with a count > 50 AND in the machine local symbol cache are looked up.  
            If the cache is empty, or if you want even low count modules included, call this explicitly
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.LookupSymbolsForModule(System.String,Microsoft.Diagnostics.Symbols.SymbolReaderOptions)">
            <summary>
            Lookup the symbols for a particular module (DLL). 
            </summary>
            <param name="simpleModuleName">The simple name (dll name without path or file extension)</param>
            <param name="symbolFlags">Optional flags that control symbol lookup</param>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.SaveAsXml(System.String,System.Boolean,System.Boolean)">
            <summary>
            Saves the stacks as a XML file (or a ZIPed XML file).  Only samples that pass the filter are saved.
            Also all interesting symbolic names should be resolved first because it is impossible to resolve them 
            later.   The saved samples CAN be regrouped later, however.  
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.Stacks.Name">
            <summary>
            This is an optional and is used for human interactions. 
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.Stacks.ExtraTopStats">
            <summary>
            ExtraTopStats is a string that is pretty important that humans see when viewing these stacks.
            Often they are aggregate statistics, or maybe warnings or error summaries.   It should be 
            well under 100 chars long.  
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.Stacks.StackSource">
            <summary>
            Stacks is just a convenience wrapper around the StackSource class.  For advanced use
            you may need to get at the stack source.   
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.String)">
            <summary>
            If you have a stackSource and want a Stacks, 
            </summary>
        </member>
        <member name="P:PerfViewExtensibility.Stacks.GuiState">
            <summary>
            There is a bunch of data that really is useful to persist to make 
            the GUI work well, (like the history of Filter selections etc) 
            but is not central to the model of the data.  This all goes into
            'GuiState'.   This data gets persisted when SaveAsXml is called and
            is passed to the GUI when OpenStackViewer is called, but otherwise
            we don't do much with it.  (unless you wish influence the GUI
            by explicitly changing it).  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.#ctor(Microsoft.Diagnostics.Tracing.Stacks.StackSource,System.String,PerfViewExtensibility.ETLDataFile,System.Boolean)">
            <summary>
            TODO should not have to specify the ETL file. 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Stacks.GetTraceEventStackSource(Microsoft.Diagnostics.Tracing.Stacks.StackSource)">
            <summary>
            Unwind the wrapped sources to get to a TraceEventStackSource if possible. 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Extensions.GetLineNextBreak(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Find the end index of the chunk of 'str' if we are at 'curColumn' and we don't want the text
            to go beyond maxColumn.    
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Extensions.GetCommandString(System.Reflection.MethodInfo)">
            <summary>
            Returns strings of the from COMMANDNAME arg1Name [arg2Name] .... 
            where [] indicate optional arguments.  
            </summary>
            <returns></returns>
        </member>
        <member name="M:PerfViewExtensibility.Extensions.GetUserCommandHelp">
            <summary>
            Return all the user command help, indexed by user command name.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Extensions.AddUserCommandHelp(System.Collections.Generic.Dictionary{System.String,PerfViewExtensibility.Extensions.CommandHelp},System.String,System.String)">
            <summary>
            Given the name of the extension DLL (extName) and the xml help file for the extension xmlHelp
            Find the XML comments for all commands and add them to the 'userComandHelp' dictionary.  
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.Extensions.CommandHelp">
            <summary>
            Represents the help for a method. 
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.Extensions.CommandHelpParam">
            <summary>
            Represents the help for a single parameter
            </summary>
        </member>
        <member name="T:PerfViewExtensibility.Commands">
            <summary>
            Commands is an actual use of the extensibility functionality.   Normally a 'Commands'
            class is compiled into a user defined DLL.
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpEventsAsXml(System.String,System.String)">
            <summary>
            Dump every event in 'etlFileName' (which can be a ETL file or an ETL.ZIP file), as an XML file 'xmlOutputFileName'
            If the output file name is not given, the input filename's extension is changed to '.etl.xml' and that is used. 
            
            This command is particularly useful for EventSources, where you want to post-process the data in some other tool.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.SaveCPUStacks(System.String,System.String)">
            <summary>
            Save the CPU stacks from 'etlFileName'.  If the /process qualifier is present use it to narrow what
            is put into the file to a single process.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.SaveScenarioCPUStacks(System.String)">
            <summary>
            Save the CPU stacks for a set of traces.
            
            If 'scenario' is an XML file, it will be used as a configuration file.
            
            Otherwise, 'scenario' must refer to a directory. All ETL files in that directory and
            any subdirectories will be processed according to the default rules.
            
            Summary of config XML:      ([] used instead of brackets)
                [ScenarioConfig]
                    [Scenarios files="*.etl" process="$1.exe" name="scenario $1" /]
                [/ScenarioConfig]
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpEventSourceManifests(System.String,System.String,System.String)">
            <summary>
            If there are System.Diagnostics.Tracing.EventSources that are logging data to the ETL file
            then there are manifests for each of these EventSources in event stream.  This method 
            dumps these to 'outputDirectory' (each manifest file is 'ProviderName'.manifest.xml)
            
            If outputDirectory is not present, then the directory 'EtwManifests' in the same directory
            as the 'etlFileName' is used as the output directory.  
            If 'pattern' is present this is a .NET regular expression and only EventSources that match 
            the pattern will be output. 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpJSHeapAsEtlFile(System.String)">
            <summary>
            This is a test hook.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.JSGCDumpFromETLFile(System.String,System.String)">
            <summary>
            Generate a GCDumpFile of a JavaScript heap from ETW data in 'etlFileName'
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DotNetGCDumpFromETLFile(System.String,System.String,System.String)">
            <summary>
            Generate a GCDumpFile of a DotNet heap from ETW data in 'etlFileName', 
            need to have a V4.5.1 runtime (preferably V4.5.2) to have the proper events.    
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpRawDotNetGCHeapEvents(System.String,System.String,System.String)">
            <summary>
            Pretty prints the raw .NET GC dump events (GCBulk*) with minimal processing as XML.   This is mostly
            useful for debugging, to see if the raw data sane if there is a question on why something is not showing
            up properly in a more user-friendly view.  
            </summary>
            <param name="etlFileName">The input ETW file containing the GC dump events</param>
            <param name="processId">The process to focus on.  0 (the default) says to pick the first process with Bulk GC events.</param>
            <param name="outputFileName">The output XML file.</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpGCDumpFile(System.String)">
            <summary>
            Dumps a GCDump file as XML.  Useful for debugging heap dumping issues.   It is easier to read than 
            what is produced by 'WriteGCDumpAsXml' but can't be read in with as a '.gcdump.xml' file.  
            </summary>
            <param name="gcDumpFileName"></param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.WriteGCDumpAsXml(System.String,System.String)">
            <summary>
            Dumps a GCDump file as gcdump.xml file.  THese files can be read back by PerfView.   
            </summary>
            <param name="gcDumpFileName">The input file (.gcdump)</param>
            <param name="outputFileName">The output file name (defaults to input file with .gcdump.xml suffix)</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DumpRegisteredManifest(System.String,System.String)">
            <summary>
            Given a name (or guid) of a provider registered on the system, generate a '.manifest.xml' file that 
            represents the manifest for that provider.   
            </summary>  
        </member>
        <member name="M:PerfViewExtensibility.Commands.Listen(System.String)">
            <summary>
            Opens a text window that displays events from the given set of event source names
            By default the output goes to a GUI window but you can use the /LogFile option to 
            redirect it elsewhere.  
            </summary>
            <param name="etwProviderNames"> a comma separated list of event sources or registered ETW provider</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DirectorySize(System.String,System.String)">
            <summary>
            Creates perfView.xml file that represents the directory size of 'directoryPath' and places
            it in 'outputFileName'.  
            </summary>
            <param name="directoryPath">The directory whose size is being computed (default to the current dir)</param>
            <param name="outputFileName">The output fileName (defaults to NAME.dirSize.PerfView.xml.zip) where NAME is
            the simple name of the directory.</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.PerfScript(System.String,System.String)">
            <summary>
            Creates a .perfView.xml.zip that represents the profiling data from a perf script output dump. Adding a
            --threadtime tag enables blocked time investigations on the perf script dump.
            </summary>
            <param name="path">The path to the perf script dump, right now, either a file with suffix perf.data.dump,
            .trace.zip or .data.txt will be accepted.</param>
            <param name="threadTime">Option to turn on thread time on the perf script dump.</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.TextHistogram(System.String)">
            <summary>
            Creates a stack source out of the textFileName where each line is a frame (which is directly rooted)
            and every such line has a metric of 1.  Thus it allows you to form histograms for these lines nicely
            in perfView.  
            </summary>
            <param name="textFilePath"></param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ProjectNMetaData(System.String)">
            <summary>
            Reads a project N metaData.csv file (From ILC.exe)  and converts it to a .GCDump file (a heap)
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ReflectionUse(System.String)">
            <summary>
            This is used to visualize the Project N ILTransformed\*.reflectionlog.csv file so it can viewed 
            in PerfVIew.   
            </summary>
            <param name="reflectionLogFile">The name of the file to view</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ImageSize(System.String,System.String)">
            <summary>
            ImageSize generates a XML report (by default inputExeName.imageSize.xml) that 
            breaks down the executable file 'inputExeName' by the symbols in it (fetched from
            its PDB.  The PDB needs to be locatable (either on the _NT_SYMBOL_PATH, or next to 
            the file, or in its original build location).   This report can be viewed with
            PerfView (it looks like a GC heap).  
            </summary>
            <param name="inputExeName">The name of the EXE (or DLL) that you wish to analyze.  If blank it will prompt for one.</param>
            <param name="outputFileName">The name of the report file.  Defaults to the inputExeName
            with a .imageSize.xml suffix.</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.PdbSignature(System.String)">
            <summary>
            Dumps the PDB signature associated with pdb 'pdbName'
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.GetDynamicAssemblySymbols(System.String)">
            <summary>
            Listen for the CLR CodeSymbols events and when you find them write them 
            to the directory targetSymbolCachePath using standard symbol server conventions
            (Name.Pdb\GUID-AGE\Name.Pdb)
            
            Usage 
            </summary>
            <param name="targetSymbolCachePath"></param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.GCStats(System.String)">
            <summary>
            Computes the GCStats HTML report for etlFile.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ServerGCReport(System.String)">
            <summary>
            Outputs some detailed Server GC analysis to a file.
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.JITStats(System.String)">
            <summary>
            Computes the JITStats HTML report for etlFile.  
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ListProviderKeywords(System.String)">
            <summary>
            Gets the ETW keywords (bitset definitions of what can be turned on in the provider) for a given provider. 
            Currently does not work for EventSources 
            </summary>
            <param name="providerNameOrGuid">The name or GUID of the provider to look up</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ListProvidersInProcess(System.String)">
            <summary>
            returns a list of providers that exist (can be enabled) in a particular process.  Currently EventSouces 
            are returned as GUIDs.  
            </summary>
            <param name="processNameOrId">The process name (exe without extension) or process ID of the process of interest.</param>
        </member>
        <member name="M:PerfViewExtensibility.Commands.ListPublishedProviders">
            <summary>
            returns a list of all providers that have published their meta-data to the Operating system.  This does NOT
            include EventSources and is a long list.  Some of these are not actually active and thus will have no effect
            if they are enabled (see ListProvidersInProcess). 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.StripFileExt(System.String)">
            <summary>
            Strips the file extension for files and if extension is .etl.zip removes both.
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.GetTraceEventsWithProcessFilter(PerfViewExtensibility.ETLDataFile)">
            <summary>
            Gets the TraceEvents list of events from etlFile, applying a process filter if the /process argument is given. 
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.SaveCPUStacksForProcess(PerfViewExtensibility.ETLDataFile,Microsoft.Diagnostics.Tracing.Etlx.TraceProcess,Diagnostics.Tracing.StackSources.FilterParams,System.String)">
            <summary>
            Save the CPU stacks for an ETL file into a perfView.xml.zip file.
            </summary>
            <param name="etlFile">The ETL file to save.</param>
            <param name="process">The process to save. If null, save all processes.</param>
            <param name="filter">The filter to apply to the stacks. If null, apply no filter.</param>
            <param name="outputName">The name of the file to output data to. If null, use the default.</param>
        </member>
        <member name="T:PerfViewExtensibility.Commands.ScenarioConfig">
            <summary>
            The configuration data for an ETL file dumped by SaveCPUStacksForProcess.
            </summary>
        </member>
        <member name="F:PerfViewExtensibility.Commands.ScenarioConfig.InputFile">
            <summary>
            The file to read in.
            </summary>
        </member>
        <member name="F:PerfViewExtensibility.Commands.ScenarioConfig.ProcessFilter">
            <summary>
            The name of the process of interest for the scenario.
            
            If null, use heuristic detection.
            </summary>
        </member>
        <member name="F:PerfViewExtensibility.Commands.ScenarioConfig.StartTime">
            <summary>
            The relative time to start taking samples from the ETL file.
            
            Set to double.NegativeInfinity to take samples from the beginning.
            </summary>
        </member>
        <member name="F:PerfViewExtensibility.Commands.ScenarioConfig.EndTime">
            <summary>
            The time to stop taking samples from the ETL file.
            
            Set to double.PositiveInfinity to take samples until the end.
            </summary>
        </member>
        <member name="M:PerfViewExtensibility.Commands.DeserializeScenarioConfig(System.Xml.XmlReader,System.Xml.XmlWriter,System.IO.TextWriter,System.String)">
            <summary>
            Parse a scenario config XML file, creating a mapping of filenames to file configurations.
            </summary>
            <param name="reader">The XmlReader to read config data from.</param>
            <param name="output">The XmlWriter to write a corresponding scenario-set definition to.</param>
            <param name="log">The log to write progress to.</param>
            <param name="baseDir">The base directory for relative path lookups.</param>
            <returns>A Dictionary mapping output filenames to ScenarioConfig objects holding configuration information.</returns>
            <remarks>
            Example config file:
            <ScenarioConfig>
            <Scenarios files="*.etl" />
            <Scenarios files="foo.etl.zip" name="scenario $1" process="bar" start="500" end="1000" />
            </ScenarioConfig>
            
            Attributes on Scenarios element:
            - files (required)
              The wildcard file pattern of ETL/ETL.ZIP files to include.
            - name (optional)
              A pattern by which to name these scenarios. Passed through to scenario-set definition.
            - process (optional)
              The name of the process of interest for this trace. If unset, the process of interest will be auto detected
            - start, end (optional)
              The start and end times of the region of interest in the trace.
            - output (optional)
              Specify name of output perfview.xml.zip.  This is needed to allow outputting different scenarios with the same etl file name to different file. 
            </remarks>
        </member>
        <member name="M:PerfViewExtensibility.Commands.FindProcessOfInterest(PerfViewExtensibility.ETLDataFile)">
            <summary>
            Heuristically find the process of interest for a given ETL trace.
            </summary>
            <param name="etlFile">The ETL file to search.</param>
            <returns>The "most interesting" process in the trace.</returns>
        </member>
        <member name="T:PerfViewModel.StackWindowGuiState">
            <summary>
            This class effectively serializes GUI state in the StackWindow.  It is 
            simply a strongly typed version of the XML data.  
            </summary>
        </member>
        <member name="T:PerfViewModel.FilterGuiState">
            <summary>
            This class effectively serializes the GUI state of the filter parameters.  It is 
            simply a strongly typed version of the XML data.  
            </summary>
        </member>
        <member name="T:PerfViewModel.TextBoxGuiState">
            <summary>
            This class effectively serializes the GUI state a single historyTextBox.  It is 
            simply a strongly typed version of the XML data.  
            
            
            </summary>
        </member>
        <member name="M:PerfViewModel.TextBoxGuiState.ReadFromXml(System.Xml.XmlReader)">
            <summary>
            Assumes we are ON the 'MyName' node below.  Readers in the values.  
            Leaves the reader on the EndElement.   
               <MyName>
                 <Value>myValue</Value>
                 <History>
                   <string>old</string>
                 </History>
               </MyName>
            </summary>
        </member>
        <member name="M:PerfViewModel.TextBoxGuiState.ReadStringList(System.Xml.XmlReader)">
            <summary>
            Reads a string list in XMLSerialization format.   Assumes we are on MyList element
            to start, and ends having read the end element of MyList.  
                 <MyList>
                   <string>elem1</string>
                   <string>elem2</string>
                   <string>elem3</string>
                 </MyList>
            </summary>
        </member>
        <member name="T:DotNetHeapDumper">
            <summary>
            This class dumps the .NET GC Heap using ETW events.   
            </summary>
        </member>
        <member name="M:DotNetHeapDumper.DumpAsEtlFile(System.Int32,System.String,System.IO.TextWriter,Graphs.MemoryGraph,DotNetHeapInfo)">
            <summary>
            Dump the  dot net Heap for process 'processID' to the etl file name 'etlFileName'.  Send diagnostics to 'log'.
            If 'memoryGraph is non-null also update it to contain the heap Dump.  If null you get just the ETL file. 
            returns true if successful. 
            </summary>
        </member>
        <member name="M:DotNetHeapDumper.Dump(System.Int32,Graphs.MemoryGraph,System.IO.TextWriter,DotNetHeapInfo)">
            <summary>
            Add the nodes of the .NET heap for the process 'processID' to 'memoryGraph' sending diagnostic
            messages to 'log'.  If 'memoryGraph' is null, the ETW providers are triggered by we obviously
            don't update the memoryGraph.  Thus it is only done for the side effect of triggering a .NET heap 
            dump. returns true if successful. 
            </summary>
        </member>
        <member name="T:DotNetHeapDumpGraphReader">
            <summary>
            Reads a .NET Heap dump generated from ETW
            </summary>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.#ctor(System.IO.TextWriter)">
            <summary>
            A class for reading ETW events from the .NET runtime and creating a MemoryGraph from it.   This only works on V4.5.1 of the runtime or later.  
            </summary>
            <param name="log">A place to put diagnostic messages.</param>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.Read(System.String,System.String,System.Double)">
            <summary>
            Read in the memory dump from javaScriptEtlName.   Since there can be more than one, choose the first one
            after double startTimeRelativeMSec.  If processId is non-zero only that process is considered, otherwise it considered
            the first heap dump regardless of process.  
            </summary>
        </member>
        <member name="P:DotNetHeapDumpGraphReader.DotNetHeapInfo">
            <summary>
            If set before Read or Append is called, keep track of the additional information about GC generations associated with .NET Heaps.  
            </summary>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.SetupCallbacks(Graphs.MemoryGraph,Microsoft.Diagnostics.Tracing.TraceEventDispatcher,System.String,System.Double)">
            <summary>
            Sets up the callbacks needed to do a heap dump (work need before processing the events()
            </summary>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.ConvertHeapDataToGraph">
            <summary>
            After reading the events the graph is not actually created, you need to post process the information we gathered 
            from the events.  This is where that happens.   Thus 'SetupCallbacks, Process(), ConvertHeapDataToGraph()' is how
            you dump a heap.  
            </summary>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.GetModuleForImageBase(System.UInt64)">
            <summary>
            Given a module image base, return a Module instance that has all the information we have on it.  
            </summary>
        </member>
        <member name="M:DotNetHeapDumpGraphReader.GetModuleForAddress(System.UInt64)">
            <summary>
            if 'addressInModule' points inside any loaded module return that module.  Otherwise return null
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_typeID2TypeIndex">
            <summary>
            Converts a raw TypeID (From the ETW data), to the graph type index)
            </summary>
        </member>
        <member name="T:DotNetHeapDumpGraphReader.RCWInfo">
            <summary>
            Remembers addition information about RCWs.  
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_typeBlocks">
            <summary>
            We gather all the BulkTypeTraceData into a list m_typeBlocks which we then process as a second pass (because we need module info which may be after the type info).  
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_staticVarBlocks">
            <summary>
            We gather all the BulkTypeTraceData into a list m_typeBlocks which we then process as a second pass (because we need module info which may be after the type info).  
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_ccwBlocks">
            <summary>
            We gather all the GCBulkRootCCWTraceData into a list m_ccwBlocks which we then process as a second pass (because we need type info which may be after the ccw info).  
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_nodeBlocks">
            <summary>
            We gather all the GCBulkNodeTraceData events into a list m_nodeBlocks.  m_curNodeBlock is the current block we are processing and 'm_curNodeIdx' is the node within the event 
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_edgeBlocks">
            <summary>
            We gather all the GCBulkEdgeTraceData events into a list m_edgeBlocks.  m_curEdgeBlock is the current block we are processing and 'm_curEdgeIdx' is the edge within the event 
            </summary>
        </member>
        <member name="F:DotNetHeapDumpGraphReader.m_typeIntern">
            <summary>
            We want type indexes to be shared as much as possible, so this table remembers the ones we have already created.  
            </summary>
        </member>
        <member name="P:DotNetHeapInfo.CorruptedObject">
            <summary>
            If we could not properly walk an object, this is incremented. 
            Hopefully this is zero.  
            </summary>
        </member>
        <member name="P:DotNetHeapInfo.UndumpedSegementRegion">
            <summary>
            This is the number of bytes we had to skip because of errors walking the segments.
            </summary>
        </member>
        <member name="P:DotNetHeapInfo.SizeOfAllSegments">
            <summary>
            This is the sum of all space in the GC segments.    
            </summary>
        </member>
        <member name="P:DotNetHeapInfo.Segments">
            <summary>
            The memory regions that user objects can be allocated from
            </summary>
        </member>
        <member name="M:DotNetHeapInfo.GenerationFor(System.UInt64)">
            <summary>
            Given an object, determine what GC generation it is in.  Gen 3 is the large object heap
            returns -1 if the object is not in any GC segment. 
            </summary>
        </member>
        <member name="T:Controls.HistoryComboBox">
            <summary>
            A trivial variation on a ComboBox that always remembers the last several entries entered into it.
            It is intended to be a drop-in replacement for TextBox.  
            </summary>
        </member>
        <member name="E:Controls.HistoryComboBox.TextEntered">
            <summary>
            This event fires when focus is lost or and Enter is typed in the box.  
            </summary>
        </member>
        <member name="E:Controls.HistoryComboBox.Enter">
            <summary>
            This fires only when the enter character is typed or a combo box item is selected.  
            </summary>
        </member>
        <member name="M:Controls.HistoryComboBox.FireEnter(System.Object,System.Windows.RoutedEventArgs)">
            <summary>
            Force an callback as if you hit the Enter Key.  
            </summary>
        </member>
        <member name="M:Controls.HistoryComboBox.ValueUpdate">
            <summary>
            If someone is data-bound to me, update them.
            </summary>
        </member>
        <member name="T:Controls.TextEditorControl">
            <summary>
            A TextEditorControl is a richTextBox with search, open, and save (basically notepad)
            </summary>
            <summary>
            TextEditorControl
            </summary>
        </member>
        <member name="P:Controls.TextEditorControl.IsReadOnly">
            <summary>
            Is the user allowed to modify the text. 
            </summary>
        </member>
        <member name="P:Controls.TextEditorControl.Document">
            <summary>
            The document representing the text in the Editor.   Most manipuation operations 
            are through this object (via TextPointers and TextRanges).  
            </summary>
        </member>
        <member name="P:Controls.TextEditorControl.Text">
            <summary>
            The body of the editor as text.  Generally this is not the best way of retriving the
            data.   You should be using operators TextRange or TextPointer fetched from Document.  
            This is more of a sample of how to use TextRange and TextPointer.  
            </summary>
        </member>
        <member name="M:Controls.TextEditorControl.AppendText(System.String)">
            <summary>
            Appends text to the editor's text buffer. 
            </summary>
        </member>
        <member name="M:Controls.TextEditorControl.OpenText(System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:Controls.TextEditorControl.GotoLine(System.Int32)">
            <summary>
            Selects the line at 'lineNum' (the first line is 1).   Will select the last line
            if lineNum is greater than the number of lines.   It is actually counting paragraphs
            so lines that are not text don't count (effectively it is counting line feeds. 
            </summary>
        </member>
        <member name="M:Controls.TextEditorControl.Find(System.String)">
            <summary>
            Finds 'pattern' in the text starting at the current selection point and wrapping around
            until all the text is searched.  It will set the selected text to the found text and
            return a TextPointer to the beginning of the selected text (or null if it fails. 
            </summary>
            <param name="pattern">The .NET regular expression to match.</param>
            <returns>Returns a text pointer to the found text or null if not matched. </returns>
        </member>
        <member name="M:Controls.TextEditorControl.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:Controls.TextEditorWriter">
            <summary>
            TextEditorWriter creates a TextWriter that sends it TextEditor.  
            </summary>
        </member>
        <member name="T:Controls.TextEditorWindow">
            <summary>
            Interaction logic for TextEditorWindow.xaml
            </summary>
            <summary>
            TextEditorWindow
            </summary>
        </member>
        <member name="F:Controls.TextEditorWindow.HideOnClose">
            <summary>
            If set simply hide the window rather than closing it when the user requests closing. 
            </summary>
        </member>
        <member name="M:Controls.TextEditorWindow.InitializeComponent">
            <summary>
            InitializeComponent
            </summary>
        </member>
        <member name="T:ClrProfiler.ClrProfilerParser">
            <summary>
            #Overview
            
            A ClrProfilerParser knows how to parse a CLRProfiler log file generated by ClrProfiler.exe Its job is
            to understand the file format and to the really basic decoding/decompression so that the upper level
            software can interpret stacks easily. What this means in practice is that ClrProfilerParser is
            responsible for decoding the stack trace information.
            
            Some attempt was made to make this very efficient. It should be able to handle Gig+ files without too
            much trouble.
            
            The basic model is that ClrProfilerParser has an event for every Profiler event in the log file.
            The user creates a 'CLrProfilerParser' subscribes to the events of interest and then calls ReadFile
            which will cause the events to fire.    
            
            See the (#if'ed out) very small sample code:#SampleProgram at the bottom of this file for an actual
            use example.
            </summary>
        </member>
        <member name="M:ClrProfiler.ClrProfilerParser.GetTopOfStack(ClrProfiler.ProfilerStackTraceID,System.UInt32)">
            <summary>
            Gets the Stack ID for the top 'frameCount' frames. 
            </summary>
        </member>
        <member name="M:ClrProfiler.ClrProfilerParser.ReadFile(System.String)">
            <summary>
            Actually read in a Profiler log file and call the any events the user subscribed to.  
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:ClrProfiler.ClrProfilerParser.Abort">
            <summary>
            Indicates that 'ReadFile' should return immediately.   
            </summary>
        </member>
        <member name="P:ClrProfiler.ClrProfilerParser.AllocIdLimit">
            <summary>
            Returns the ID that is one larger than the last valid Alloc ID.   Note that this is valid only AFTER a completed ReadFile() call
            </summary>
            <returns></returns>
        </member>
        <member name="P:ClrProfiler.ClrProfilerParser.StackIdLimit">
            <summary>
            Returns the ID that is one larger than the last valid Stack ID.   Note that this is valid only AFTER a completed ReadFile() call
            </summary>
            <returns></returns>
        </member>
        <member name="P:ClrProfiler.ClrProfilerParser.MethodIdLimit">
            <summary>
            Returns the ID that is one larger than the last valid Method ID, Note that this is valid only AFTER a completed ReadFile() call
            </summary>
        </member>
        <member name="P:ClrProfiler.ClrProfilerParser.TypeIdLimit">
            <summary>
            Returns the ID that is one larger than the last valid FieldType ID, Note that this is valid only AFTER a completed ReadFile() call
            </summary>
        </member>
        <member name="P:ClrProfiler.ClrProfilerParser.ModuleIdLimit">
            <summary>
            Returns the ID that is one larger than the last valid Module ID, Note that this is valid only AFTER a completed ReadFile() call
            </summary>
        </member>
        <member name="F:ClrProfiler.ClrProfilerParser.abort">
            <summary>
            Used to abort the run early
            </summary>
        </member>
        <member name="F:ClrProfiler.ClrProfilerParser.fileIdStackInfoId">
            <summary>
            the CLRProfiler log file has a rather painful encoding of stacks that is hard to design an
            efficient and intuitive access API around because the ID for the 'n' record represents a
            chunk of the stack, not just one frame (and try to handle both having allocation nodeId information
            sometimes and sometimes not).  We remove this complexity during reading.  The entries in the
            StackInfo table represent exactly one frame, and the enties int the AllocInfo table represent
            exactly one allocation nodeId/Size and its stack.  
            
            However during reading, we need to convert from the ID used in the file, to the one used
            internally.  The table below remembers this mapping (from ID used in the file, to ID used
            in either StackInfo or AllocInfo.
            
            If the upper bit is reset (entry is postive) then the Id is for the StackInfo table, 
            otherwise mask off 0x80000000 and the entry is for the AllocInfo table
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerStackTraceID">
            <summary>
            Represents one stack trace. It represents a tuple that has a 'NextFrame' field and a 'Method' field,
            but does so more efficiently than could be done if it were an object. See the
            code:ClrProfilerCallBacks.NextFrame and code:ClrProfilerCallBacks.Method for more on usage.
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerAllocID">
            <summary>
            Represents one allocation 
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerMethod">
            <summary>
            Represents a single method in the target application 
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerType">
            <summary>
            Represents a nodeId allocated by the target application
            </summary>
        </member>
        <member name="M:ClrProfiler.ProfilerType.FixGenerics(System.String)">
            <summary>
            The format for generics in the file is not what you see in source code.  Fix this....
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerModule">
            <summary>
            Represents a module (DLL file), loaded by the target application
            </summary>
        </member>
        <member name="F:ClrProfiler.ProfilerModule.name">
            <summary>
            This is the full path name of the module
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerStack">
            <summary>
            If you need a real object to represent the stack frame, 
            </summary>
        </member>
        <member name="T:ClrProfiler.ProfilerGCSegment">
            <summary>
            The GC Memory is allocated in relatively large contiguous regions called 'segments' ProfilerGCSegment
            represents one such segment. (Only used in code:ClrProfilerCallBacks.GCStart and EndGC)
            </summary>
        </member>
        <member name="T:ClrProfiler.GcRootKind">
            <summary>
            Indiciates where the GC root came from (Only used in code:ClrProfilerCallBacks.OnGCRoot)
            </summary>
        </member>
        <member name="T:ClrProfiler.GcRootFlags">
            <summary>
            Indiciates  any special properties the GC root can have (Only used in code:ClrProfilerCallBacks.OnGCRoot)
            </summary>
        </member>
        <member name="T:ClrProfiler.GCSimulation">
            <summary>
            This allows you to keep track of allocations that have not been freed.  
            </summary>
        </member>
        <member name="T:MemoryStats.MemoryNode">
            <summary>
            A MemoryNode represents a set of memory regions in a process.   MemoryNodes can have children and thus
            form trees.   Node also have names, 
            </summary>
        </member>
        <member name="M:MemoryStats.MemoryNode.MemorySnapShotForProcess(System.Int32)">
            <summary>
            This is the main entry point into the MemoryNode class.  Basically giving a process ID return
            a MemoryNode that represents the roll-up of all memory in the process.  
            </summary>
        </member>
        <member name="F:MemoryStats.MemoryNode.Name">
            TODO REMOVE 
                    public IntPtr BaseAddress;
                    public IntPtr AllocationBase;
                    public PageProtection AllocationProtect;
                    public IntPtr RegionSize;
                    public MemoryState State;
                    public PageProtection Protect;
                    public MemoryType Type;
                    public ulong Blocks;
                    public ulong Id;
                    public ulong Storage;
                    public string Type;
                     ***
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryState.MEM_COMMIT">
            <summary>
            Indicates committed pages for which physical storage has been allocated, either in memory or in the paging file on disk.
            </summary>
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryState.MEM_FREE">
            <summary>
            Indicates free pages not accessible to the calling process and available to be allocated. 
            For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
            </summary>
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryState.MEM_RESERVE">
            <summary>
            Indicates reserved pages where a range of the process's virtual address space is reserved without
            any physical storage being allocated. 
            For reserved pages, the information in the Protect member is undefined.
            </summary>
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryType.MEM_IMAGE">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of an image section.
            </summary>
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryType.MEM_MAPPED">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of a section.
            </summary>
        </member>
        <member name="F:MemoryStats.NativeMethods.MemoryType.MEM_PRIVATE">
            <summary>
            Indicates that the memory pages within the region are private (that is, not shared by other processes).
            </summary>
        </member>
        <member name="T:JavaScriptDumpGraphReader">
            <summary>
            Reads a JavaScript Heap dump generated from ETW
            </summary>
        </member>
        <member name="M:JavaScriptDumpGraphReader.#ctor(System.IO.TextWriter)">
            <summary>
            A class for reading ETW events from JScript9.dll and creating a MemoryGraph from it.  
            </summary>
            <param name="log">A place to put diagnostic messages.</param>
        </member>
        <member name="M:JavaScriptDumpGraphReader.Read(System.String,System.Int32,System.Double)">
            <summary>
            Read in the memory dump from javaScriptEtlName.   Since there can be more than one, choose the first one
            after double startTimeRelativeMSec.  If processId is non-zero only that process is considered, otherwise it considered
            the first heap dump regardless of process.  
            </summary>
        </member>
        <member name="M:JavaScriptHeapDumper.DumpAsEtlFile(System.Int32,System.String,System.IO.TextWriter,Graphs.MemoryGraph)">
            <summary>
            Dump the JSHeap for process 'processID' to the etl file name 'etlFileName'.  Send diagnostics to 'log'.
            If 'memoryGraph is non-null also update it to contain the JSDump.  If null you get just the ETL file. 
            returns true if successful. 
            </summary>
        </member>
        <member name="M:JavaScriptHeapDumper.Dump(System.Int32,Graphs.MemoryGraph,System.IO.TextWriter)">
            <summary>
            Add the nodes of the JS heap for the process 'processID' to 'memoryGraph' sending diagnostic
            messages to 'log'.  If 'memoryGraph' is null, the ETW providers are triggered by we obviously
            don't update the memoryGraph.  Thus it is only done for the side effect of triggering a JS heap 
            dump. returns true if successful. 
            </summary>
        </member>
        <member name="M:PdbScopeMemoryGraph.LoadModuleMap(System.String,System.String)">
            <summary>
            Loads the Module map associate with the EXE/DLL dllFilePath.    This allows us to decode $N_ prefixes in project N Dlls.   
            </summary>
        </member>
        <member name="M:PdbScopeMemoryGraph.EmitNodesForGaps(System.Collections.Generic.Queue{PdbScopeMemoryGraph.Section},System.UInt64,System.UInt64)">
            <summary>
            Figures out the best name for an unknown region (a gap).  'sections' is the SORTED list of PE file sections
            so we can give the gaps the best names and to deal with the padding at the end of sections.   
            </summary>
        </member>
        <member name="T:ProjectNMetaDataLogReader">
            <summary>
            Knows how to read the project N metadata.csv file format
            </summary>
        </member>
        <member name="M:PerfViewLogger.StartAndStopTimes">
            <summary>
            Logs the time (relative to this event firing) when the trace was started and stopped.
            This is useful for circular buffer situations where that may not be known.  
            </summary>
        </member>
        <member name="M:PerfViewLogger.Tick(System.String)">
            <summary>
            Logged at consistent intervals so we can see where circular buffering starts.  
            </summary>
        </member>
        <member name="T:Triggers.Trigger">
            <summary>
            Things that any Trigger needs to implement.  Basically you need to be able to stop it (IDispose) 
            and you need to ask its status (which allows the user to see that the trigger is monitoring things
            properly.  
            
            Note that Triggers will NOT die on their own, since they are MONITORS and are kept alive by the
            monitoring thread they start.  You can only kill them by disposing them.  
            </summary>
        </member>
        <member name="P:Triggers.Trigger.Status">
            <summary>
            Get something useful about the state of the trigger, can return the empty string if there 
            is nothing useful to say.  
            </summary>
        </member>
        <member name="M:Triggers.Trigger.Dispose">
            <summary>
            Used to stop the trigger (Triggers must be disposed explicitly since the timer keeps them
            alive unless disposed).   
            </summary>
        </member>
        <member name="T:Triggers.PerformanceCounterTrigger">
            <summary>
            PerformanceCounterTrigger is a class that knows how to determine if a particular performance counter has
            exceeded a particular threshold.   
            </summary>
        </member>
        <member name="M:Triggers.PerformanceCounterTrigger.#ctor(System.String,System.Single,System.IO.TextWriter,System.Action{Triggers.PerformanceCounterTrigger})">
            <summary>
            Creates a new PerformanceCounterTrigger based on a specification.   Basically this specification is 
            a condition which is either true or false at any particular time.  Once the PerformanceCounterTrigger
            has been created, you can call 'IsCurrentlyTrue()' to see if the condition holds.  
            </summary>
            <param name="spec">This is of the form CATEGORY:COUNTERNAME:INSTANCE OP NUM  where OP is either a 
            greater than or less than sign, NUM is a floating point number and CATEGORY:COUNTERNAME:INSTANCE
            identify the performance counter to use (same as PerfMon).  For example 
            
            .NET CLR Memory:% Time in GC:_Global_>20  
               
            Will trigger when the % Time in GC for the _Global_ instance (which represents all processes) is
            greater than 20. 
            
            Processor:% Processor Time:_Total>90
            
            Will trigger when the % processor time exceeds 90%.  
            </param>
            <param name="decayToZeroHours">If nonzero, the threshold will decay to 0 in this amount of time.</param>
            <param name="log">A place to write messages.</param>
            <param name="onTriggered">A delegate to call when the threshold is exceeded</param>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.Spec">
            <summary>
            The specification of the Performance counter trigger that was given when it was constructed.  
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.Threshold">
            <summary>
            The threshold number that got passed in the spec in the constructor.   This never changes over time.   
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.IsGreaterThan">
            <summary>
            Returns true if the perf counter must be great than the threshold to trigger.  
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.DecayToZeroHours">
            <summary>
            The value of DecayToZeroHours parameter passed to the constructor of the trigger. 
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.MinSecForTrigger">
            <summary>
            The amount of time in seconds that the performance counter needs to be above the threshold to be considered triggered
            This allows you to ignore transients.   By default the value is 3 seconds.   
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.EffectiveThreshold">
            <summary>
            If DecayToZeroHours is set, the threshold changes over time.  This property returns the value after
            being adjusted by DecayToZeroHours. 
            </summary>
        </member>
        <member name="P:Triggers.PerformanceCounterTrigger.CurrentValue">
            <summary>
            This is the value of the performance counter since the last tie 'Update()' was called.  
            </summary>
        </member>
        <member name="M:Triggers.PerformanceCounterTrigger.SpawnCounterIn64BitProcessIfNecessary">
            <summary>
            If you are in a 32 bit process you don't see 64 bit perf counters.  Returns true if we needed to do this.  
            </summary>
        </member>
        <member name="M:Triggers.PerformanceCounterTrigger.Update">
            <summary>
            Update 'CurrentValue' to the live value of the performance counter. 
            </summary>
        </member>
        <member name="T:Triggers.ETWEventTrigger">
            <summary>
            A class that triggers when 
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.StopOnException(System.String,System.String,System.IO.TextWriter,System.Action{Triggers.ETWEventTrigger})">
            <summary>
            Triggers on a .NET Exception of a particular name.  
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.GCTooLong(System.Int32,System.Single,System.String,System.IO.TextWriter,System.Action{Triggers.ETWEventTrigger})">
            <summary>
            Triggers if an .NET GC takes longer than triggerDurationMSec
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.StopOnGen2GC(System.String,System.IO.TextWriter,System.Action{Triggers.ETWEventTrigger})">
            <summary>
            Stops on a Gen 2 GC.  
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.AppFabricTooLong(System.Int32,System.Single,System.String,System.IO.TextWriter,System.Action{Triggers.ETWEventTrigger})">
            <summary>
            Triggers if AppFabric Cache service takes longer than triggerDurationMSec
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.#ctor(System.String,System.IO.TextWriter,System.Action{Triggers.ETWEventTrigger})">
            <summary>
            Create a new trigger that uses a specification to indicate what ETW events to trigger on.   
            
            spec Syntax
                PROVIDER/TASK/OPCODE;NAME1=VALUE1;NAME2=VALUE2 ...      // Opcode is optional and defaults to Info
                PROVIDER/EVENTNAME;NAME1=VALUE1;NAME2=VALUE2 ...        
            
            TASK can be Task(NNN)
            OPCODE can be Opcode(NNN)
            EVENTNAME can be EventID(NNN)
            
            Names can begin with @ which mean they are reserved for the implementation.  Defined ones are
                 Keywords=XXXX                             // In hex, default ulong.MaxValue.  
                 Level=XXXX                                // 1 (Critical) - 5 (Verbose) Default = 4 (Info)
                 Process=ProcessNameOrID                   // restricts to a particular process
                 FieldFilter=FieldName Op Value            // Allows you to filter on a particular field value OP can be &lt; &gt; = and ~ (which means RegEx match)
                                                           // You can repeat this and you get the logical AND operator (sorry no OR operator right now). 
                 BufferSizeMB=NNN                          // Size of buffer used for trigger session.  
            If TriggerMSec is non-zero then it measures the duration of a start-stop pair.   
                 TriggerMSec=NNN                           // Number of milliseconds to trigger on.  
                 DecayToZeroHours=NNN                      // Trigger decays to 0 in this amount of time. 
                 StopEvent=PROVIDER/TASK/OPOCDE            // Default is stop if event is a start, otherwise it is 1 opcode larger (unless 0 in which case 1 event ID larger). 
                 StartStopID=XXXX                          // Indicates the payload field name that is used as the correlation ID to pair up start-stop pairs
                                                            // can be 'ThreadID' or ActivityID if those are to be used.  
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.Start">
            <summary>
            Actually starts listening for ETW events.  Stops when 'Dispose()' is called.  
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.PassesFieldFilters(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Returns true of 'data' passes any field filters we might have.  
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Triggers.ETWEventTrigger.#ctor(System.IO.TextWriter)">
            <summary>
            The ETWEventTrigger has a bunch of configuration options.  You set them and then call 'Start()' to begin
            waiting for the proper ETW event.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.ProviderGuid">
            <summary>
            The provider to listen for
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.TriggerMSec">
            <summary>
            Only used if OpcodeName is null (assumed to be 'Stop') and this is the duration between start and stop.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.StartStopID">
            <summary>
            This is the name of the argument that correlates start-stop pairs.  
            It can be ThreadID as well as ActivityID as well as payload field names, If null it uses the first argument.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.TriggerPredicate">
            <summary>
            Called when Task/Opcode is matched to see if you really want to trigger
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.ProcessFilter">
            <summary>
            If non-null, this string is process ID or the name of the process (exe name without path or extension)
            If this is present only processes that match this filter will trigger the stop.  Note that if a 
            process name is given, only one process with that name (at any one time) will trigger the stop.    
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.BufferSizeMB">
            <summary>
            The buffer size used for the session that listens for the ETW trigger.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.DecayToZeroHours">
            <summary>
            If TriggerForceToZeroHours is set then the effective TriggerDurationMSec is decrease over time so
            that it is 0 after TriggerForceToZeroHours.  Thus if TriggerDurationMSec is 10,000 and TriggerForceToZeroHours
            is 24 after 6 hours the trigger will be 7,500 and after 6 hourse it is 5000.  This insures that eventually
            you will trigger.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.OnTriggered">
            <summary>
            This is the callback when something is finally triggered.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.FieldFilters">
            <summary>
            These represent filters (they are logically AND if there is more than one) that 
            operatin on field values of the event.  
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.EffectiveTriggerDurationMSec">
            <summary>
            Returns the actual threshold that will trigger a stop taking TriggerForceToZeroHours in to account
            </summary>
        </member>
        <member name="P:Triggers.ETWEventTrigger.TriggeredMessage">
            <summary>
            A detailed message about exactly what caused the triggering.   Useful to display to the user after the trigger has fired.  
            </summary>
        </member>
        <member name="F:Triggers.ETWEventTrigger.SessionNamePrefix">
            <summary>
            This is the name that is used for the Session to listen to ETW Trigger events.  
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.GetContextIDForEvent(Microsoft.Diagnostics.Tracing.TraceEvent)">
            <summary>
            Given a traceEvent payload 'data', return a contextID that will be used to correlate 'Start' and 'Stop'
            opcode events
            </summary>
        </member>
        <member name="T:Triggers.ETWEventTrigger.ETWEventTriggerInfo">
            <summary>
            Used to hold the event name for the start or stop events.   
            </summary>
        </member>
        <member name="M:Triggers.ETWEventTrigger.ETWEventTriggerInfo.DefaultStopEvent">
            <summary>
            Given an start event, get the stop event.   If the event Name ends in 'Start' we simply change it to 'Stop'
            Otherwise the stop event is the the next event ID after the start event.  
            </summary>
            <returns></returns>
        </member>
        <member name="T:Triggers.EventFieldFilter">
            <summary>
            Describes a field filter Thus Foo > 5 means that the field Foo has to be greater than 5.   
            </summary>
        </member>
        <member name="T:Triggers.EventLogTrigger">
            <summary>
            A class that will cause a callback if a particular event is writen to the windows event log.  
            </summary>
        </member>
        <member name="M:Triggers.EventLogTrigger.#ctor(System.String,System.IO.TextWriter,System.Action{Triggers.EventLogTrigger})">
            <summary>
            Will cause a callback if the an event is written to the Windows Application Event Log that matches the regular expression
            'spec'.   'spec' can also have the form EventLogName@RegExp
            </summary>
        </member>
        <member name="T:Triggers.PerformanceCounterMonitor">
            <summary>
            Used to log a particular counter to the ETL file as a PerfViewLogger event. 
            </summary>
        </member>
        <member name="M:Triggers.PerformanceCounterMonitor.#ctor(System.String,System.IO.TextWriter)">
            <summary>
            Started monitoring of a performance counter.  Spec is of the form CATEGORY:COUNTERNAME:INSTANCE@INTERVAL
            log is a TextWriter to write diagnostic information to.  
            </summary>
        </member>
        <member name="M:Triggers.PerformanceCounterMonitor.Dispose">
            <summary>
            Stops the monitoring.  
            </summary>
        </member>
        <member name="T:Triggers.StartStopKey">
            <summary>
            The key used to correlate start and stop events;
            </summary>
        </member>
        <member name="T:XamlGeneratedNamespace.GeneratedInternalTypeHelper">
            <summary>
            GeneratedInternalTypeHelper
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateInstance(System.Type,System.Globalization.CultureInfo)">
            <summary>
            CreateInstance
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.GetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Globalization.CultureInfo)">
            <summary>
            GetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.SetPropertyValue(System.Reflection.PropertyInfo,System.Object,System.Object,System.Globalization.CultureInfo)">
            <summary>
            SetPropertyValue
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.CreateDelegate(System.Type,System.Object,System.String)">
            <summary>
            CreateDelegate
            </summary>
        </member>
        <member name="M:XamlGeneratedNamespace.GeneratedInternalTypeHelper.AddEventHandler(System.Reflection.EventInfo,System.Object,System.Delegate)">
            <summary>
            AddEventHandler
            </summary>
        </member>
    </members>
</doc>
